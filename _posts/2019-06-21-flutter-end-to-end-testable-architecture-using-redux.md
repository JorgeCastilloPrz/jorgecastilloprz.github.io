---
layout: post
current: post
cover: assets/images/taj.jpg
navigation: True
title: Flutter - Testable architecture using Redux
date: 2019-06-21 12:15:00
tags: [flutter,architecture]
class: post-template
subclass: 'post'
author: jorge
---

Architecture concepts are often common across platforms. Let's learn how to build an end to end architecture for Flutter using Redux. Our main focus will be testability. âœ…

### Unidireccional data flow

This is something we've heard many times already, so let me point very rapidly the key points of an architecture like Redux which implements this pattern. The most basic diagram for Redux might look like this:

![redux](assets/images/redux.png)

Let's go briefly over all the pieces:

* **View**: The rendering side of the program. Our Widget tree in Flutter. It dispatches actions on start or as the result of user interactions.
* **Action**: The intent of changing state. Usually called after verbs that reflect that intent. E.g: *UpdatePhotos*, *ToggleLoading*, or even *RouteToPhotoDetail*. (Because why not? The current displayed screen could also be part of the app state)
* **Reducer**: Reducers are **pure functions** with the form `AppState appReducer(AppState state, action)`. So they take the current app state and an action, apply the changes required by the action and return **a new app state**.
* **Store**: Where the app state is. The state generated by reducers is stored here. A state change in the `Store` triggers a `View` redraw. So the `Widgets` directly affected will redraw themselves to match the new state.

As you can see, events flow in a single direction. On top of that, I'd like to remark the following details from a holistic point of view:

* The app has a single source of truth, the state. That doesn't mean you can't **compose that state for better concern separation**, e.g: having one substate per screen, or split view and app state. The important bit here is that the state is composed and unique, so we can render our app at any point in time just by feeding it a current snapshot of the state.
* Having state as a single source of truth allows you to serialize it, send it over network and restore it in a different machine, which allows you to reproduce any app state for debugging purposes, shortcut development workflows, share development scenarios with your team mates, and much more.
* **State is immutable**. It goes from a previous state to a new state through reducers and actions as described above. State is replaced by the new one, never mutated. That's key so we can ensure the only state change occurring in the app is done by the reducers.
* Immutable state allows us to compare different snaphots of the state for optimizing the rendering phase (you don't need to render again a Widget when its state remains unchanged).
* It usually comes handy to override `toString()` in the state, so you can easily log it during development, or send it to a tracking system.
* In some not statically typed languages, actions carry a `type` field or property to determine their intent. Given we've got classes here we can just reflect that intent by the action class name.
* Actions can contain a payload as the required data to perform a state change. So the reducer gets an action, extracts the payload and uses it to perform the required state update.
* Actions are also immutable.
* When we say "reducers are *pure functions*", we mean they just take their input arguments (current app state + action) and generate a new app state. They don't try to access anything in the external world.
* It's recommendable to split and compose reducers, so your global reducer is a composition of minor reducers intentionally segregated to cover different domain areas or different parts of the state tree.
* If you are able to log / serialize / persist / track actions and state, then you're literally able to reproduce how users get to a given scenario, since any app state is the result of the initial app state plus all the actions applied on top of it. In other words, you can fast forward state, rewind state, or reproduce any state snapshot.
* When state is immutable and state changes work like a state machine, your program becomes deterministic. That means you can reason about it in a considerably easier way.
* When state is deterministic you can create advanced tooling for developers that leverages app state inspection hence debugging capabilities.

Let's come back down to earth and jump into a practical example now.

### Wallpapers app

This is gonna be a very simple app for the sake of the example. We essentially want to load a bunch of wallpapers from a service and show a loader in the meantime, like this:

![wallpapers app](assets/images/wallpapers_app.gif){:height="712px"}

So this screen will have 2 different states: A list of photos and a boolean determining whether the view is loading or not.

```dart
@immutable
class AppState {
  final List<Photo> photos;
  final bool isPhotosListLoading;

  const AppState({@required this.photos, @required this.isPhotosListLoading});

  @override
  String toString() {
    return 'AppState: {photos: $photos}';
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AppState &&
          runtimeType == other.runtimeType &&
          ListEquality().equals(photos, other.photos) &&
          isPhotosListLoading == other.isPhotosListLoading;

  @override
  int get hashCode => photos.hashCode ^ isPhotosListLoading.hashCode;
}
```

We are also overriding `==` (equals) and `hashCode`. Equality will be required when we need to compare states to avoid rendering again when the state has not changed.

Now let's create our reducers. For this we'll need to add the [redux.dart](https://pub.dev/packages/redux/) package to our `pubspec.yaml`. This package will bring the basic Redux features we need to implement our architecture.

Our `appReducer` is going to be a composition of two different reducers.

```dart
AppState appReducer(AppState state, action) {
  return AppState(
      photos: photosReducer(state.photos, action),
      isPhotosListLoading: photosListViewStateReducer(state.isPhotosListLoading, action));
}
```

The `photosReducer` will handle state changes for updating the photos in the `AppState`. It essentially gets the new photos list passed by the action and replaces the old one in the `Store`. We are being intentionally simple here.

```dart
final photosReducer =
    TypedReducer<List<Photo>, UpdatePhotosAction>(_updatePhotosReducer);

List<Photo> _updatePhotosReducer(List<Photo> state, UpdatePhotosAction action) {
  return action.photos;
}
```

Note that we use `TypedReducer` from [redux.dart](https://pub.dev/packages/redux/) package. `TypedReducer` binds a state change to a given action type, so we can avoid the boilerplate for comparing action types by ourselves. Without this, we would need to have a big switch case where we would compare the `action.runtimeType` with each one of the action types to trigger the proper reducers when required.

We need to pass a function reference (in this case `__updatePhotosReducer`) to call every time an `UpdatePhotosAction` arrives.

In the other hand, we have a `photosListViewStateReducer` that will respond to the `TogglePhotosListLoadingAction` for updating the toggle state. The action will pass the new value for it:

```dart
final photosListViewStateReducer =
    TypedReducer<bool, TogglePhotosListLoadingAction>(_togglePhotosListLoading);

bool _togglePhotosListLoading(bool state, TogglePhotosListLoadingAction action) {
  return action.isLoading;
}
```

This is probably a really simple state segregation approach. You could do it in the way that better matches your needs. In this case I am separating what we could consider app state (`photos`) from view state (`isPhotosListLoading`).

If we had more widgets on screen, or multiple screens, we would most likely combine different reducers for the view state for example. [You've got `combineReducers` method for that in the `redux.dart` package](https://github.com/johnpryan/redux.dart/blob/master/doc/combine_reducers.md#reducing-boilerplate-in-a-type-safe-way).

Logics for reducing a single state can be combined. As a very brief parenthesis, let's say we had a more complex scenario where we needed separate logics for adding or removing photos to/from the list state in the `Store`. We could use `combineReducers` and `TypedReducer` for achieving our goal with just a few lines! ðŸ‘Œ

```dart
Reducer<List<Photo>> photosListViewStateReducer = combineReducers<List<Photo>>([
  new TypedReducer<List<String>, AddPhotoAction>(addItemReducer),
  new TypedReducer<List<String>, RemovePhotoAction>(removeItemReducer),
]);
```
Our state will be reduced by any of those reducers, depending on the action that arrives. `TypedReducers` will do the magic.

Now getting back to our example, we got a way to reduce any state changes for both `UpdatePhotosAction` and `TogglePhotosListLoadingAction`, but what about the actual actions items? We still didn't have a look to those. Well, they're indeed very simple.

```dart
class TogglePhotosListLoadingAction {
  final bool isLoading;

  const TogglePhotosListLoadingAction({this.isLoading});
}


class UpdatePhotosAction {
  final List<Photo> photos;

  const UpdatePhotosAction({this.photos});
}
```

Both actions reflect the need for a state change, and can carry some payload for it.

But there's still an issue. We are able to show / hide a loader and show a list of photos by updating it's state. But **who's fetching the photos?**

That's where a package like [redux_thunk](https://pub.dev/packages/redux_thunk) comes into play. It essentially allows you to write asynchronous actions!

Let's say we've got a `PhotosRepository` that abstracts the source of the data in a simple way.
