<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator>
  <link href="https://jorgecastilloprz.github.io/tag/fp/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://jorgecastilloprz.github.io/" rel="alternate" type="text/html" />
  <updated>2025-07-05T09:28:11+00:00</updated>
  <id>https://jorgecastilloprz.github.io/tag/fp/feed.xml</id>

  
  
  

  
    <title type="html">üë®‚Äçüíª Jorge Castillo | </title>
  

  
    <subtitle>You'll find all my tech posts here.</subtitle>
  

  

  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  
  

  
    <entry>
      <title type="html">When Android met FP</title>
      <link href="https://jorgecastilloprz.github.io/when-android-met-fp" rel="alternate" type="text/html" title="When Android met FP" />
      <published>2018-07-21T17:25:00+00:00</published>
      <updated>2018-07-21T17:25:00+00:00</updated>
      <id>https://jorgecastilloprz.github.io/when-android-met-fp</id>
      <content type="html" xml:base="https://jorgecastilloprz.github.io/when-android-met-fp">&lt;p&gt;Learning new things is hard, and rejecting the unknown is part of human nature. There‚Äôs some reaction inside us that makes our minds reject anything new in some way.&lt;/p&gt;

&lt;p&gt;Then time flies and you start getting used to it.&lt;/p&gt;

&lt;h3 id=&quot;getting-rid-of-the-noise&quot;&gt;Getting rid of the noise&lt;/h3&gt;

&lt;p&gt;Even if it‚Äôs part of our nature, these reactions are irrational and not related in any way to how we think. It‚Äôs just how we react in the beginning. We can be scared, but then there‚Äôs always our intuition beyond that. If we detect that there‚Äôs something valuable on that new thing, we smartly put all our efforts on trying to understand and remove the noise around it. That‚Äôs also part of our nature, as engineers. We are proactive.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/images/arrival1.jpeg&quot; alt=&quot;Arrival 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Remember the first time we saw ReactiveX logo, some years ago?.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;the-jargonÔ∏è&quot;&gt;The Jargon‚Ñ¢Ô∏è&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;assets/images/jargon.jpeg&quot; alt=&quot;Jargon&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A new language and its new grammars. A new jargon. A new paradigm, which at the end of the day is also a language by itself in the most generic sense. Each term on it seems incomprehensible and hard to master, &lt;strong&gt;not because it‚Äôs complex, but because it‚Äôs different&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;And we are curious. We try to learn each one of the terms separately. It looks like the easiest way to gradually understand the whole thing. &lt;strong&gt;Either&lt;/strong&gt; we &lt;strong&gt;Try&lt;/strong&gt;, or abandon. We‚Äôll probably need to be good &lt;strong&gt;Readers&lt;/strong&gt; though.&lt;/p&gt;

&lt;p&gt;The more we use this terms, the more natural they feel all together. It requires time and to use the language out there, in the real world. And practice is key.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/images/arrival3.jpeg&quot; alt=&quot;Arrival 3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If we keep moving, we‚Äôll eventually have a glimpse on the connection between all the symbols. That‚Äôs how to learn a language. We will get familiarized with how and when to use each one of them. We‚Äôll start to master the syntax, and to know how to read it. We already went through this process many times in the past, didn‚Äôt we?&lt;/p&gt;

&lt;p&gt;After some time, we finally realize something. The jargon is not as scary as it was anymore. We start to notice some interesting connections with our own language, the one we are used to. Our knowledge keeps growing, and our mind stays open.&lt;/p&gt;

&lt;p&gt;The more we learn about these connections, our hability to express ourselves becomes broader. &lt;strong&gt;We gain perspective and resources to communicate and to solve problems&lt;/strong&gt;. Even though we can end up not using this language in the future, these new concepts will make us richer in terms of expressivity.&lt;/p&gt;

&lt;p&gt;Ideally we‚Äôll start mixing languages and concepts, becoming able to use the best of all worlds to express our needs and solve our problems.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/images/arrival4.jpeg&quot; alt=&quot;arrival 4&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;reaching-familiarity&quot;&gt;Reaching familiarity&lt;/h3&gt;

&lt;p&gt;After this little history, lets get back to what is worth about FP. The more we read about it and use it, the more we‚Äôll notice something else.&lt;/p&gt;

&lt;p&gt;There‚Äôs the same bunch of words repeated every single time, regardless of the problems we are solving. We map, flatMap, fold, combine, compose‚Ä¶ Sounds like something we‚Äôve been doing all this time, doesn‚Äôt it?.&lt;/p&gt;

&lt;p&gt;FP can be a bit overwhelming in the beginning, that‚Äôs for sure. But as soon as you understand the main purpose of its main pieces, you‚Äôll find yourself using the same stuff all the time. These abstractions talk about how to operate over the data, which is not related to any semantics for a given problem, but apply to any different use cases.&lt;/p&gt;

&lt;p&gt;You‚Äôll get familiar with all those if you want to, in case you‚Äôre not already, and when that time comes, you‚Äôll find it much easier than what it seemed to be.&lt;/p&gt;

&lt;p&gt;Once you do, you‚Äôll have enough knowledge to go even further and read your programs in a more abstract way based on their behaviours and the way they operate with the data. Including mobile apps. That‚Äôll make those much more testable and deterministic, therefore easier to reason about.&lt;/p&gt;

&lt;h3 id=&quot;do-we-need-a-change&quot;&gt;Do we need a change?&lt;/h3&gt;

&lt;p&gt;As engineers, our nature is to evolve and learn new stuff. We already do that, on a daily basis. Moving to FP is &lt;strong&gt;obviously not required&lt;/strong&gt;, though. You‚Äôre free to keep the same approaches and concepts you feel comfortable with, and it‚Äôs completely legit. Same story for not changing languages and paradigms.&lt;/p&gt;

&lt;p&gt;Said that, it‚Äôs always a good thing to learn new things and be able to evaluate, because they might fit. They might be helpful. Once you are ready for it, you‚Äôll be on your full right to reject them if you feel they‚Äôre not fitting for you or your team.&lt;/p&gt;

&lt;h3 id=&quot;about-arrow-itself&quot;&gt;About Arrow itself&lt;/h3&gt;

&lt;p&gt;As a team, we would like people to become interested on learning new ways of coding and become able to evaluate and bring those to discussion topics into their professional environments, which we believe is always constructive and positive.&lt;/p&gt;

&lt;p&gt;The same way, we‚Äôre so willing to keep getting productive feedback, and also trying to find ways to make this new paradigm more accessible to everybody. If we come back to the jargon ‚Äúproblems‚Äù and its learning curve (&lt;strong&gt;which we‚Äôre very aware of&lt;/strong&gt;), we‚Äôd never hesitate on changing any names if the community finds any clear issues with any of the current ones. I‚Äôd say we‚Äôve done it more than a couple of times already . We don‚Äôt care a lot about the jargon, but more about it being usable and understandable.&lt;/p&gt;

&lt;h3 id=&quot;final-thoughts&quot;&gt;Final thoughts&lt;/h3&gt;

&lt;p&gt;Let‚Äôs always keep in mind that Functional Programming is a paradigm, which have been proven to be useful and effective many times before. It‚Äôs not about platforms anymore. &lt;strong&gt;Paradigms can be applied over any problem and any program&lt;/strong&gt;, the same than languages. There‚Äôs not just a subset of programs that are valid for it. It‚Äôs neither about being better or worse than OOP.&lt;/p&gt;

&lt;p&gt;Android, as a system with a frontend layer, database and network queries, and much more, is based on side effects. But we learned long ago to abstract us away from these. That‚Äôs how layered / decoupled architectures were born. As long as you‚Äôre outside of the ‚Äúdangerous‚Äù boundaries, you‚Äôre free to program in the way that fits better your needs.&lt;/p&gt;

&lt;p&gt;Let‚Äôs also remember that to have some fear to the unknown defines us, the same way as being curious and adapting to new things. Promoting change implies growth as persons and engineers.&lt;/p&gt;

&lt;p&gt;Also note that there is a big educational component required before to accept a new paradigm that we‚Äôve not been used to by history. We believe it‚Äôs worth it.&lt;/p&gt;

&lt;p&gt;Stay curious and continuously learning, that‚Äôs part of what we are.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/images/arrival5.jpeg&quot; alt=&quot;arrival 5&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This post has not any intentions on promoting conflict or blaming anybody‚Äôs attitude, but to promote constructive feedback. Not just for Arrow or FP, but anything. We are all on the same boat, and one of the most valuable things we have in the Android community, in my opinion, is that we know how to progress all together. There are not many communities that can say that.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;want-to-support-me&quot;&gt;Want to support me?&lt;/h3&gt;

&lt;p&gt;If you reached this point you might consider supporting me for boosting my will to write. If that‚Äôs the case, here you have a button, really appreciated! ü§ó&lt;/p&gt;

&lt;p&gt;Supported or not, I will keep writing and providing content for free ‚úÖ&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.buymeacoffee.com/jorgecastillo&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://cdn.buymeacoffee.com/buttons/default-orange.png&quot; alt=&quot;Buy Me A Coffee&quot; style=&quot;height: 51px !important;width: 217px !important;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;related-links&quot;&gt;Related links&lt;/h3&gt;

&lt;p&gt;If you‚Äôre interested on &lt;a href=&quot;https://arrow-kt.io&quot;&gt;Arrow&lt;/a&gt; and Functional Programming over Kotlin, have a read one some of the other articles I‚Äôve posted about this subject. You can also &lt;a href=&quot;https://twitter.com/JorgeCastilloPR&quot;&gt;follow me on Twitter&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://jorgecastilloprz.github.io/kotlin-fp-does-it-make-sense&quot;&gt;Kotlin Functional Programming: Does it make sense?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://jorgecastilloprz.github.io/kotlin-dependency-injection-with-the-reader-monad&quot;&gt;Kotlin Dependency Injection with the Reader Monad&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://jorgecastilloprz.github.io/kotlin-fp-1-monad-stack&quot;&gt;Kotlin Functional Programming I: Monad Stack&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://jorgecastilloprz.github.io/kotlin-fp-2-monad-transformers&quot;&gt;Kotlin Functional Programming II: Monad Transformers&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://jorgecastilloprz.github.io/tail-recursion-and-how-to-use-it-in-kotlin&quot;&gt;Tail recursion and how to use it in Kotlin&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://jorgecastilloprz.github.io/kotlin-purity-and-function-memoization&quot;&gt;Kotlin purity and function memoization&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Jorge Castillo</name>
        
        
      </author>

      

      
        <category term="kotlin" />
      
        <category term="android" />
      
        <category term="fp" />
      

      
        <summary type="html">Learning new things is hard, and rejecting the unknown is part of human nature. There‚Äôs some reaction inside us that makes our minds reject anything new in some way.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Kotlin Functional Programming, Does it make sense?</title>
      <link href="https://jorgecastilloprz.github.io/kotlin-fp-does-it-make-sense" rel="alternate" type="text/html" title="Kotlin Functional Programming, Does it make sense?" />
      <published>2017-10-18T15:18:00+00:00</published>
      <updated>2017-10-18T15:18:00+00:00</updated>
      <id>https://jorgecastilloprz.github.io/kotlin-fp-does-it-make-sense</id>
      <content type="html" xml:base="https://jorgecastilloprz.github.io/kotlin-fp-does-it-make-sense">&lt;p&gt;Functional programming can feel like a big wave of fresh air over a beautiful landscape at sunset. The flowers are literally us. üòç üåº (maybe?)&lt;/p&gt;

&lt;p&gt;Ok no jokes: it‚Äôs clearly worth it!&lt;/p&gt;

&lt;h3 id=&quot;is-kotlin-a-fp-lang&quot;&gt;Is Kotlin a FP lang?&lt;/h3&gt;

&lt;p&gt;When we think about Kotlin, OOP is always implicit. But that‚Äôs not strictly necessary. Kotlin is still &lt;strong&gt;open to a different paradigm&lt;/strong&gt; thanks to some of its built-in features. I‚Äôm referring to FP here.&lt;/p&gt;

&lt;p&gt;If you take a careful look at the built-in features, you will find some very obvious ones like &lt;em&gt;higher order functions or the power to use functions as first class citizens&lt;/em&gt;. That means you‚Äôre able to treat functions as values in Kotlin. This feature is very related to &lt;strong&gt;function oriented styles&lt;/strong&gt;, even if that does not strictly mean Functional Programming. But it opens a whole new world of approaches for you.&lt;/p&gt;

&lt;p&gt;Having the possibility to pass functions as arguments, return them as other functions results, or store them in variables or lists for later usage, opens the language to new techniques like &lt;strong&gt;deferring execution&lt;/strong&gt;. If you return functions on your different layers instead of already computed values, what you get back from it is a composed deferred computation, or in other words, &lt;strong&gt;lazy evaluation&lt;/strong&gt;. Your computations are deferred in time, still not run, so you keep control over when to do that.&lt;/p&gt;

&lt;p&gt;This is completely related to FP, and you will see why in the following lines.&lt;/p&gt;

&lt;p&gt;Also &lt;em&gt;functions as first class citizens&lt;/em&gt;, as you already know, means you can just use functions the same way and on the same places you were using classes in Java. That means you can declare those at a package level, if you want to. Because honestly, do we always need to play with instances all the time?, or is it kind of ‚Äúimposed‚Äù by our paradigm and the libraries we use?&lt;/p&gt;

&lt;p&gt;Actually if you take a careful look at the language you will find tons of additional features that you can find on many functional languages: Type inference, operator overloading, good support for syntax extensions (implemented by &lt;em&gt;extension functions&lt;/em&gt;), collection combinators as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flatMap&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fold&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reduce&lt;/code&gt;‚Ä¶, or even &lt;strong&gt;algebraic data types&lt;/strong&gt; (sealed classes + data classes).&lt;/p&gt;

&lt;p&gt;The language is even abstracting some logics and behaviors to functions, and not to classes, as you would do in OOP. That‚Äôs something very usual on &lt;strong&gt;FP vs OOP&lt;/strong&gt; comparisons, since those logics are abstracted to easily reusable functions on Functional Programming.&lt;/p&gt;

&lt;p&gt;A good example of this would be again the collections API functions mentioned before. I.e: mapping a collection (or calling &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map(f: (A) -&amp;gt; B)&lt;/code&gt; over it) means applying a mapping function to each one of its elements and returning a new collection containing all those. So if we split this behavior in two parts:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Abstraction of mapping generic behavior, which is appliable over any collection. That would be the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt; high order function by itself, so it applies a given &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt; lambda for all the elements in a collection.&lt;/li&gt;
  &lt;li&gt;Implementation details for the current execution are delegated to the function being passed as an argument (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So recaping a bit, looks like Kotlin implements some approaches very related to FP langs.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Does it mean it is or can be considered a Functional Programming language?&lt;/strong&gt; Probably not, or probably yes ¬Ø\_(„ÉÑ)_/¬Ø. I mean, what a functional programing lang is, is not clearly defined and it depends on where you look at or which posts you read. The boundaries for that could be a bit blurry. But honestly, I think that is not such important here.&lt;/p&gt;

&lt;p&gt;At the end of the day, truth is Kotlin is ‚Äúunlocking‚Äù the chance to do pure Functional Programming just by adding some interesting built-in features. So if we wanted to achieve it, we definitely could.&lt;/p&gt;

&lt;h3 id=&quot;but-should-we&quot;&gt;But should we?&lt;/h3&gt;

&lt;p&gt;It‚Äôs a well funded question, since we could just keep doing OOP and that‚Äôs all, given that it worked for us since ever. So why to switch?&lt;/p&gt;

&lt;p&gt;Well, let‚Äôs expose three really important benefits from Functional Programming to start with.&lt;/p&gt;

&lt;h3 id=&quot;referential-transparency&quot;&gt;Referential Transparency&lt;/h3&gt;

&lt;p&gt;A function should be completely clear and straightforward about what‚Äôs it asking for, and what‚Äôs it giving in return. That means &lt;strong&gt;side effects are not welcome&lt;/strong&gt; here, since those break this term. Just by looking at a function return type and it‚Äôs parameter types, I must be able to know exactly what can I get out of it. So the goal is to make the function completely explicit, including all the possible return cases.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;When you are writing public apis I‚Äôd suggest to always expose types&lt;/strong&gt; (by convention). Even if the lang allows you to avoid them on return types thanks to type inference. Type inference is great, but public APIs from functions should not be affected by it, since that &lt;strong&gt;breaks public API contract readability&lt;/strong&gt;, hence referential transparency. At the same time, please, feel free (and I promote it) to use type inference in any other cases, like function bodies.&lt;/p&gt;

&lt;h3 id=&quot;purity&quot;&gt;Purity&lt;/h3&gt;

&lt;p&gt;If I call a function one billion times, and I pass it the &lt;strong&gt;same argument values&lt;/strong&gt; every single time, I should get the exact &lt;strong&gt;same result&lt;/strong&gt; every single time. That means the function is not performing any side effects on its body. Its not doing anything unexpected under the hood. It is not trying to access or modify any external state, neither using any third party APIs that could potentially throw.&lt;/p&gt;

&lt;p&gt;For side effects we understand things that escape your program‚Äôs logic control, like printing to console, rendering to a display, sending metrics to an analytics system in a server, performing an HTTP request, storing something on a cache (no matter whether it‚Äôs persistence or memory), and much more. As soon as your functions provoke changes in the observable world or try to read from it, they contain side effects.&lt;/p&gt;

&lt;p&gt;Effects can be slow, fail (throw), be cancelled, mutate the state of your program‚Ä¶ etc. They leverage ambig√ºity within your program.&lt;/p&gt;

&lt;p&gt;Functional Programming is all about purity, since its mainly based on pushing side effects out of your architecture. We don‚Äôt want side effects to introduce non-determinism into our call stack. Because that removes the ability to do ‚Äúlocal reasoning‚Äù over our code. If we can‚Äôt be certain of what a method is gonna do for all the cases (no exceptions, pun intended!) then we can‚Äôt really reason about it in a deterministic way.&lt;/p&gt;

&lt;p&gt;One good example of this could be compiler optimizations. If every time your code calls &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add(1, 2)&lt;/code&gt; it returns &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3&lt;/code&gt;, compiler can infer that and replace all calls like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add(1, 2)&lt;/code&gt; in your code base by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3&lt;/code&gt;, the actual result. Compiler optimizations are just possible when code is deterministic, given they work by inferring behaviors over code.&lt;/p&gt;

&lt;p&gt;So overall we will always try to find ways to get rid of state and side effects on all your architecture layers where you do not really require having those.&lt;/p&gt;

&lt;p&gt;To achieve that we can do something we‚Äôve been doing since ages ago in OP: &lt;strong&gt;Depend on abstractions&lt;/strong&gt;. When your architecture targets abstractions and you leave implementation details for runtime (&lt;strong&gt;side effects are implementation details, keep that in mind please!&lt;/strong&gt;), you achieve a complete pure architecture. That‚Äôs how you achieve what‚Äôs called &lt;strong&gt;Concern separation&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;So a code based on purity is a predictable code, and hidden bugs cannot happen easily. Think about this: Usually in OOP, bugs are related to state change or race conditions provoked by state change on arbitrary (unexpected) points of your system. Some state is being changed somewhere behind the scenes where it shouldn‚Äôt, and boom that‚Äòs the root of the problem.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Purity means determinism, which means higher and easier testability.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;concern-separation&quot;&gt;Concern Separation&lt;/h3&gt;

&lt;p&gt;Looking at FP programs, there is a concept which is present every single time. FP programs / systems are divided in two different parts:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Algebras:&lt;/strong&gt; Compose a tree of declarative and deferred computations to implement your system logic. That‚Äôs usually done using &lt;strong&gt;algebraic data types&lt;/strong&gt; that define the operations your program is able to perform. This stack of computations &lt;strong&gt;is not gonna be run yet&lt;/strong&gt;. It‚Äôs actually just declared and we can already reason about it, but it‚Äôs waiting for us to decide when we‚Äôre ready to run it. On this step you‚Äôd usually just target abstractions (like &lt;em&gt;Typeclass&lt;/em&gt; defined behaviors or even &lt;em&gt;Free&lt;/em&gt; lifted operations. You will have details about both techniques in future posts). So your code still does not know anything about concrete semantics, just completely abstract behaviors.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Runtime:&lt;/strong&gt; After providing the whole execution tree we can decide to run it. At that moment you usually provide all the semantics / implementation details (side effects) needed for it. So at that very moment and not before, you are resolving the ambiguity imposed by the abstractions.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This two steps are present on &lt;strong&gt;any&lt;/strong&gt; FP program. And they are a quite big improvement on how we model our programs, since we are now open to (and able) to define them in a completely declarative and abstract style. So we could validate and test our whole execution tree in an end to end black box scenario just by running the algebras (our program) by passing in the implementation details that are more convenient for us at &lt;strong&gt;runtime&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Those implementation details will be the side effects, and &lt;strong&gt;will be the pieces we will end up replacing in tests by test doubles&lt;/strong&gt;. We want to achieve isolation from frameworks, after all. For anything else we can still use our production code, since it‚Äôs gonna be all &lt;strong&gt;pure functions that don‚Äôt need to be mocked&lt;/strong&gt;. We can safely use the production ones as they are, being able to exercise a big chunk of our production codebase and just mock the edges and a couple more pieces. That indeed unlocks black box testing.&lt;/p&gt;

&lt;h3 id=&quot;does-kotlin-have-everything-needed-to-do-pure-fp&quot;&gt;Does Kotlin have everything needed to do pure FP?&lt;/h3&gt;

&lt;p&gt;No, it doesn‚Äôt. The language still lacks some key features that we would require in order to go for type safe pure Functional Programming.&lt;/p&gt;

&lt;p&gt;Some of those, and really important ones, could be &lt;strong&gt;Higher Kinded Types&lt;/strong&gt;, &lt;strong&gt;Typeclasses&lt;/strong&gt;, and a lot of functional constructs and abstractions. Functional programming in a complete way cannot be applied without those.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Kotlin/KEEP/pull/87&quot;&gt;There is a KEEP&lt;/a&gt; open by &lt;a href=&quot;https://www.twitter.com/raulraja&quot;&gt;Ra√∫l Raja&lt;/a&gt; for the Kotlin team to ask for including Typeclasses into the language. There is a really interesting dicussion inside, and the official Kotlin team from JetBrains is evaluating this option.&lt;/p&gt;

&lt;p&gt;This doesn‚Äôt necessarily mean it will be implemented, but it is being taken into good account by them. So please, vote there if you would like to have those features built in in the Kotlin compiler!&lt;/p&gt;

&lt;p&gt;So, since there is a lot of work to do, and since we found out good approaches to implement / emulate those things, we decided to create a library for it: Arrow (&lt;a href=&quot;https://arrow-kt.io/&quot;&gt;arrow-kt.io&lt;/a&gt;)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Arrow brings Functional Programming types and abstractions to the Kotlin language.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Stay tunned for more posts about Functional Programming in Kotlin. There‚Äôs much more to come!&lt;/p&gt;

&lt;p&gt;In the meantime, you can follow me on Twitter &lt;a href=&quot;https://www.twitter.com/JorgeCastilloPr&quot;&gt;@JorgeCastilloPr&lt;/a&gt;, where I speak a lot about this topic and many other ones. I will announce new posts there! üéâ&lt;/p&gt;

&lt;p&gt;If you reached this point you might consider supporting me, üëâ&lt;a href=&quot;https://paypal.me/jorgecastilloprz&quot;&gt;here&lt;/a&gt; you have a link where you could do it. Really appreciated! ü§ó Getting support or not, I will for sure keep writing and providing content for free ‚úÖ&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Jorge Castillo</name>
        
        
      </author>

      

      
        <category term="kotlin" />
      
        <category term="fp" />
      

      
        <summary type="html">Functional programming can feel like a big wave of fresh air over a beautiful landscape at sunset. The flowers are literally us. üòç üåº (maybe?)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Kotlin purity and function memoization</title>
      <link href="https://jorgecastilloprz.github.io/kotlin-purity-and-function-memoization" rel="alternate" type="text/html" title="Kotlin purity and function memoization" />
      <published>2017-05-17T07:00:00+00:00</published>
      <updated>2017-05-17T07:00:00+00:00</updated>
      <id>https://jorgecastilloprz.github.io/kotlin-purity-and-function-memoization</id>
      <content type="html" xml:base="https://jorgecastilloprz.github.io/kotlin-purity-and-function-memoization">&lt;p&gt;Let‚Äôs learn about the benefits of ‚Äúpurity‚Äù and ‚Äúpure functions‚Äù, and how it affects caching.&lt;/p&gt;

&lt;p&gt;A pure function is a function that &lt;strong&gt;just operates over it‚Äôs input arguments to provide a result&lt;/strong&gt;. It has no side effects, which means that the function itself is not provoking any external effects that you cannot control or &lt;strong&gt;you don‚Äôt expect&lt;/strong&gt;. It‚Äôs not modifying any external state behind the scenes. So if you ran the function one trillion times for the same input arguments you would get the same result one trillion times.&lt;/p&gt;

&lt;p&gt;A pretty common example of pure function usage uses to be the one about JDK Math class functions.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;fifteen&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;abs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;arcTangent&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;atan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;90.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;arcSine&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;asin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;45.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;eight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sqrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;64.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;All those functions would always return the same results for those given arguments, with no exceptions.&lt;/p&gt;

&lt;p&gt;In java it‚Äôs easy to create pure functions. You just mark those functions as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;static&lt;/code&gt; so those cannot access any state since they aren‚Äôt bound to any enclosing class instance. The compiler itself is going to forbid modification or access to any &lt;strong&gt;non static&lt;/strong&gt; external variables from outside the function, but &lt;strong&gt;you shouldn‚Äôt either modify global static ones&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://wiki.haskell.org/Referential_transparency&quot;&gt;Referential Transparency&lt;/a&gt; is a concept definitely present on pure functions. I learned this concept from a &lt;a href=&quot;https://www.47deg.com/presentations/2017/02/18/Functional-error-handling/&quot;&gt;very interesting talk about Functional Error Handling by Raul Raja&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Referential Transparency means that the function does exactly what it promises when you call it, no more, no less. This concept is pretty beneficial for testability. If your code is most likely based on pure functions, that means it‚Äôs also more predictable. And &lt;strong&gt;predictable code is normally easier to test&lt;/strong&gt;. Side effects break referential transparency.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;assets/images/hermione.gif&quot; alt=&quot;Hermione&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Hermione found that purity doesn‚Äôt fit pretty well inside her last released app. She might use some spells to fix it.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;If you are an Android developer you know about the need to apply side effects at some point, otherwise you couldn‚Äôt render things on screen or query to an API. Well, you can &lt;strong&gt;apply those effects to the edges imposed by your system&lt;/strong&gt;. Talking about Android, we would be talking about lifecycle callbacks where Android IoC gives us the control. We will talk a bit about this again in the following paragraphs.&lt;/p&gt;

&lt;p&gt;The rest of your architecture could be totally based on &lt;strong&gt;purity-based transformations over the data&lt;/strong&gt;, if you wanted.&lt;/p&gt;

&lt;p&gt;If you pass all your dependencies as parameters all the way, you will find that you are progressively &lt;strong&gt;getting rid of state&lt;/strong&gt; across your architecture except for the edge imposed by it, that would be where the inversion of control is applied (lifecycle callbacks).&lt;/p&gt;

&lt;p&gt;In Java, we normally have state all over the place just because OOP, and because we also decide to inject dependencies through constructors / fields and keep their references retained inside class instances. But that‚Äôs our choice on that. It doesn‚Äôt mean we have a requirement to have state, neither an instance. The only meaning of this situation is that the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DI&lt;/code&gt; framework we are using is kind of forcing us to have state.&lt;/p&gt;

&lt;p&gt;If you start moving towards this mindset, you will find that you could remove a lot of classes and focus more on functions as &lt;strong&gt;first class citizens&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Also, &lt;strong&gt;having no state means no need to switch those pieces at testing time&lt;/strong&gt;. You will be completely safe by using your real production code for all those chained functions inside your tests, since there aren‚Äôt any problematic side effects creating the need for test doubles. And the testing environment should always replicate production code as much as possible, otherwise you wouldn‚Äôt be writing the right tests, isn‚Äôt it?&lt;/p&gt;

&lt;p&gt;This enables you to test your app almost end to end in a &lt;strong&gt;black box scenario&lt;/strong&gt; just by switching your View implementation (Android) and a couple more side effecting dependencies by test doubles. Purity predictability will make you capable of exercising a bunch of chained functions and easily know what to expect in return for your assertions.&lt;/p&gt;

&lt;p&gt;Also, your production dependency trees would be much shorter. Your switchable dependencies would be just the required ones to apply side effects, but other than that your connection between the inner layers would just be a bunch of pure functions calling each other to apply transformations over the data. Something that does not requires to be passed as an injected dependency.&lt;/p&gt;

&lt;p&gt;But we also have to look at the possible &lt;strong&gt;disadvantages and caveats of purity&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;-performance-consequences&quot;&gt;üò≠ Performance consequences&lt;/h3&gt;

&lt;p&gt;By getting rid of the state we are also sacrificing something important. Let‚Äôs say that we have the need for a memory cache of items loaded from the API.&lt;/p&gt;

&lt;p&gt;First of all, we see a problem on querying the API, since that‚Äôs a side effect.&lt;/p&gt;

&lt;p&gt;Well, a good approach to avoid breaking purity would be to wrap the side effect inside an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; Monad to defer its execution. This means that we are going to compose a chain of transformations over the data plus the deferred data retrieval by the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; Monad, and we will run the whole chain from the edge imposed by the system, right when we are ready for it. That will happen on our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onCreate&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onResume&lt;/code&gt; Activity / Fragment method, most likely.&lt;/p&gt;

&lt;p&gt;So all the side effects are applied on Android lifecycle callbacks, inside the view implementation. So we are safe on this.&lt;/p&gt;

&lt;p&gt;But what happens when we have to do some expensive calculations in some of the layers composed just with pure functions? Also, what would happen if we are server side and the mentioned function to do the calculation is called thousands of times?&lt;/p&gt;

&lt;p&gt;Let‚Äôs have a look on the following code snippet. It‚Äôs a class instance with some state. It‚Äôs capable of calculating the factors of any possible integer:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FactorCalculator&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;sumCache&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hashMapOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;()&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;factorCache&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hashMapOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;gt;()&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sumOfFactors&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sumCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getOrPut&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;factorsOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isFactor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;potential&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;potential&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;factorsOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factorCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getOrPut&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;toList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;filter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isFactor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sumOfFactors&lt;/code&gt; function returns a sum of all the factors from any &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt;. That value is calculated by the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;factorsOf&lt;/code&gt; function, which takes a range from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; to the current &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;number&lt;/code&gt;, converts it to a list and then filters to get just the values that are actually factors of the given &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;number&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Both functions rely on a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HashMap&lt;/code&gt; structure to cache already calculated values results for previous inputs, just to save some CPU cycles and memory. Using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map.getOrPut()&lt;/code&gt; function from Kotlin we simplify the code a bit.&lt;/p&gt;

&lt;p&gt;But we have state here, so we don‚Äôt have purity. Our functions are applying side effects over the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HashMap&lt;/code&gt; structures. So, let‚Äôs try to convert this class to a bunch of pure functions that just operate over their input parameters:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sumOfFactors&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;factorsOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;factorsOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;toList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;filter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isFactor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isFactor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;potential&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;potential&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We dropped the concept of class here, as it‚Äôs no longer needed. But during the process, we didn‚Äôt have any other choice than to drop the state since we want those functions to be pure. So we lost our memory caches forever!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/images/sad_afflec.gif&quot; alt=&quot;Sad Afflec&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Affleck realized at the bar what he lost on that refactor pushed to production hours ago&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Well, Affleck has &lt;strong&gt;good reasons to be sad&lt;/strong&gt;, since his refactor was part of some very often used code from server side, and server response timings are going to be damaged so badly because of it.&lt;/p&gt;

&lt;p&gt;Looking back at the previous snippet, it seems like we don‚Äôt have any simple possibility to keep a memory structure storing those already calculated values without provoking side effects.&lt;/p&gt;

&lt;p&gt;Well, that‚Äôs not really true and here is were the need for a feature like &lt;strong&gt;function memoization&lt;/strong&gt; comes in üéâ.&lt;/p&gt;

&lt;h3 id=&quot;-function-memoization&quot;&gt;ü§î Function memoization&lt;/h3&gt;

&lt;p&gt;It‚Äôs a feature commonly built into some programing languages like Groovy, which &lt;strong&gt;enables automatic caching of recurring function-return values&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;The idea around the concept is to provide a memory cache at a function level that stores the already calculated function result values. So if we get this feature we wouldn‚Äôt need a class instance and a field reference to store it for us anymore, it would be held as part of the function language meta-level.&lt;/p&gt;

&lt;p&gt;Languages that do not implement this out of the box don‚Äôt have hard times implementing it, although they can lose some syntactic sugar during the process.&lt;/p&gt;

&lt;p&gt;Memoizing a function is a &lt;strong&gt;metafunction&lt;/strong&gt; application. That means we are doing something to the function itself and how it works at a language meta level and not to the function results or it‚Äôs code implementation.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://objectpartners.com/2014/01/28/memoization-in-groovy/&quot;&gt;Here you have a pretty clear article&lt;/a&gt; by Brendon Anderson about how function memoization works in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Groovy&lt;/code&gt;. The code examples inside of it are pretty straightforward. I will paste one here to reduce noise so we can talk about it:&lt;/p&gt;

&lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myClosure&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;My Closure argument $x&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;memoize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;myClosure&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;myClosure&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;myClosure&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;myClosure&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You define a closure and then call the language built-in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memoize()&lt;/code&gt; method on top of it to get a memoized version for the same function. This is the resulting output after running the function those 4 times:&lt;/p&gt;

&lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;My&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Closure&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argument&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;My&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Closure&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argument&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So, quoting the article: &lt;em&gt;‚ÄúYou can see that the code inside the closure was executed only once for each distinct input parameter.‚Äù&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;That‚Äôs because the memoized version of the function is returning already cached results and not recalculating them if it‚Äôs not needed. It just replaces the resulting value with the cached one if the function was called with the same parameters than a previous call so the function code is not really run.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;This can be done because the function is pure&lt;/strong&gt;, and we can tell that we will always get the same result for the same input parameter. Otherwise we couldn‚Äôt feel safe about replacing it‚Äôs returning value with it‚Äôs cached version.&lt;/p&gt;

&lt;p&gt;So, how could I achieve the same behavior in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;?&lt;/p&gt;

&lt;h3 id=&quot;-kotlin-implementation&quot;&gt;üéÅ Kotlin implementation&lt;/h3&gt;

&lt;p&gt;Sad story here: Memoization isn‚Äôt a built-in feature for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;. I will not paste Ben Affleck here again, but I can pretty much imagine your face.&lt;/p&gt;

&lt;p&gt;Anyways, we can still implement it by ourselves so‚Ä¶&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/images/why_so_serious.gif&quot; alt=&quot;why so serious&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Take a look at this simple Kotlin implementation of the feature:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Memoize1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;values&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutableMapOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getOrPut&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;memoize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Memoize1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;memoizedSumFactors&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sumOfFactors&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;memoize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;First, let‚Äôs look at the class on top. I have used a class here so it becomes clearer to read, but I could also create an anonymous object extending the correct function type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(T) -&amp;gt; R&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;On this basic example I am just covering the case of functions with a standalone parameter that also return a value. But the same strategy could be applied for any number of function arguments.&lt;/p&gt;

&lt;p&gt;Taking a cautious look, you will notice that the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Memoize1&lt;/code&gt; class receives as function with the type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(T) -&amp;gt; R&lt;/code&gt; as a property. Then I overrided the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;invoke&lt;/code&gt; method to be able to make it‚Äôs implementation rely on a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MutableMap&lt;/code&gt;. The map is used to hold the already calculated values as an in memory cache, so the function will return a previously calculated result if the input value is contained in the map. Otherwise, the function will be run and it‚Äôs result will be stored in the map right after that.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Overriding invoke is like overriding the main application of the function, which is it‚Äôs main constructor. In Kotlin, a call with the form a() is converted to a.invoke(). You can also invoke any function by using a.invoke() by yourself. This is equivalent to apply() method from Scala.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I also added an extension method for all the functions with the form &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(T) -&amp;gt; R&lt;/code&gt;, for any &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt; types. Thanks to that one, you can call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memoize()&lt;/code&gt; over any function that receives a value and returns a result. You will get it‚Äôs memoized version in return.&lt;/p&gt;

&lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memoizedSumFactors&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;x:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sumOfFactors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;memoize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;memoizedSumFactors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// this would be the only one calculated&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;memoizedSumFactors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;memoizedSumFactors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;memoizedSumFactors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;memoizedSumFactors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As you can see on the snippet, by using this code you would get your function body run just once, and for the resting calls for the same input value we would get the cached result instead.&lt;/p&gt;

&lt;p&gt;So here we got what we where looking for! üéä&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;After writing this article, found out that the really well known library &lt;a href=&quot;https://github.com/MarioAriasC/funKTionale&quot;&gt;funKTionale&lt;/a&gt; from &lt;a href=&quot;https://github.com/MarioAriasC&quot;&gt;Mario Arias&lt;/a&gt; already &lt;a href=&quot;https://github.com/MarioAriasC/funKTionale/blob/8c36f2d411691f0fe1da62e720d0a0df2834da2d/funktionale-memoization/src/main/kotlin/org/funktionale/memoization/namespace.kt#L28&quot;&gt;implements memoization&lt;/a&gt; for Kotlin. It‚Äôs gonna become a really good example of how to enable memoization for functions up to 22 parameters.&lt;/p&gt;

&lt;p&gt;As you can see, &lt;a href=&quot;https://github.com/MarioAriasC/funKTionale/blob/8c36f2d411691f0fe1da62e720d0a0df2834da2d/funktionale-memoization/src/main/kotlin/org/funktionale/memoization/namespace.kt#L29&quot;&gt;he uses objects extending the required function types&lt;/a&gt;, instead of named classes, to provide a simpler implementation.&lt;/p&gt;

&lt;p&gt;You might think that the code is pretty boilerplate with all those extension functions and classes for the handler. This sort of &lt;em&gt;‚Äúpredef‚Äù&lt;/em&gt; files to define language extensions are pretty typical on functional programing. Truth is that thanks to this simple file that you could copy to any of your projects, you enable memoization for any possible function you want to use.&lt;/p&gt;

&lt;p&gt;So it should be worth it, isn‚Äôt it?&lt;/p&gt;

&lt;p&gt;If you want to avoid the need to implement memoization by yourself, and now that you already know what‚Äôs the concept about, you could add the dependency of &lt;em&gt;funKTionale&lt;/em&gt; to your project. If you are moving your app towards a more functional architecture, this library will be handful for you, and it‚Äôs worth it. Thanks to Mario for putting his best efforts on it.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;This should wrap things up for now. If you are interested on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt; and possible functional approaches around the language, you could want to take a look to the following articles I wrote recently about tail recursion and &lt;em&gt;Dependency Injection&lt;/em&gt; using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reader&lt;/code&gt; monad. You might agree or disagree, but those are interesting concepts pretty handful to understand:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/@JorgeCastilloPr/tail-recursion-and-how-to-use-it-in-kotlin-97353993e17f&quot;&gt;Tail recursion and how to use it in Kotlin&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/@JorgeCastilloPr/kotlin-dependency-injection-with-the-reader-monad-7d52f94a482e&quot;&gt;Kotlin Dependency Injection with the Reader Monad&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Please, feel free to add me on Twitter &lt;a href=&quot;https://twitter.com/jorgecastillopr&quot;&gt;@jorgecastillopr&lt;/a&gt; to discuss anything related (or not even related!) to this article. I usually post and retweet about &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt; and any other Android development and functional related posts.&lt;/p&gt;

&lt;p&gt;If you reached this point you might consider supporting me, üëâ&lt;a href=&quot;https://paypal.me/jorgecastilloprz&quot;&gt;here&lt;/a&gt; you have a link where you could do it. Really appreciated! ü§ó Getting support or not, I will for sure keep writing and providing content for free ‚úÖ&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Jorge Castillo</name>
        
        
      </author>

      

      
        <category term="kotlin" />
      
        <category term="fp" />
      

      
        <summary type="html">Let‚Äôs learn about the benefits of ‚Äúpurity‚Äù and ‚Äúpure functions‚Äù, and how it affects caching.</summary>
      

      
      
    </entry>
  
</feed>
