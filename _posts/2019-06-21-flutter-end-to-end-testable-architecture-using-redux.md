---
layout: post
current: post
cover: assets/images/taj.jpg
navigation: True
title: Flutter - Testable architecture using Redux
date: 2019-06-21 12:15:00
tags: [flutter,architecture]
class: post-template
subclass: 'post'
author: jorge
---

Architecture concepts are often common across platforms. Let's learn how to build an end to end architecture for Flutter using Redux. Our main focus will be testability. âœ…

### Unidireccional data flow

This is something we've heard many times already, so let me point very rapidly the key points of an architecture like Redux that implements this pattern. The most basic diagram for Redux might look like this:

![redux](assets/images/redux.png)

Let's go briefly over all the pieces:

* **View**: The rendering side of the program. Our Widget tree in Flutter. It dispatches actions on start or as the result of user interactions.
* **Action**: The intent of changing state. Usually called after verbs that reflect that intent. E.g: *UpdatePhotos*, *ToggleLoading*, or even *RouteToPhotoDetail*. (Because why not? The current displayed screen could also be part of the app state)
* **Reducer**: Reducers are **pure functions** with the form `AppState appReducer(AppState state, action)`. So they take the current app state and an action, apply the changes required by the action and return **a new app state**.
* **Store**: Where the app state is. The state generated by reducers is stored here. A state change in the `Store` triggers a `View` redraw. So the `Widgets` directly affected will redraw themselves to match the new state.

As you can see, events flow in a single direction. On top of that, I think it's important to remark the following details from a holistic point of view:

* The app has a single source of truth, the state. That doesn't mean you can't **compose that state for better concern separation**, e.g: having one substate per screen, or split view and app state. The important bit here is that the state is composed and atomic, so we can render our app at any point in time just by feeding it a current snapshot of the state.
* Having state as a single source of truth allows you to serialize it, send it over network and restore it in a different machine, which allows you to reproduce any app state for debugging purposes, shortcut development workflows, share development scenarios with your team mates, and much more.
* **State is immutable**. It goes from a previous state to a new state through reducers and actions as described above. State is replaced by the new one, never mutated. That's key so we can ensure the only state change occurring in the app is done by the reducers.
* Immutable state allows us to compare different snaphots of the state for optimizing the rendering phase (you don't need to render again a Widget when its state remains unchanged).
* It usually comes handy to override `toString()` in the state, so you can easily log it during development, or send it to a tracking system.
* In some not statically typed languages, actions carry a `type` field or property to determine their intent. Given we've got classes here we can just reflect that by the action class name.
* Actions can contain a payload as the required data to perform a state change. So the reducer would gets the action, extracts the payload and uses it to perform the required state update.
* Actions are also immutable, since they're plain objects with a minimum payload.
* When we say reducers are *pure functions* we mean they just take their input arguments (current app state + action) and generate a new app state. They don't try to access anything in the external world.
* It's common to split and compose reducers, so your global reducer is a composition of minor reducers intentionally segregated to cover different domain areas or different parts of the state tree.
* If you are able to log / serialize / persist / track actions and state, then you're literally able to reproduce how users get to a given scenario, since any app state is the result of the initial app state plus all the actions applied on top of it. In other words, you can fast forward state, rewind state, or reproduce any state snapshot.
* When state is immutable and state changes work like a state machine, your program becomes deterministic. That means you can reason about it in a considerably easier way.
* When state is deterministic you can create advanced tooling for developers that leverages app state inspection hence debugging capabilities.

Let's come back down to earth and jump into a practical example now.

### Wallpapers app

This is gonna be a very simple app for the sake of the example. We essentially want to load a bunch of wallpapers from a service and show a loader in the meantime, like this:

![wallpapers app](assets/images/wallpapers_app.gif){:height="712px"}

So this screen will have 2 different states: A list of photos and a boolean determining whether the view is loading or not.

```dart
@immutable
class AppState {
  final List<Photo> photos;
  final bool isPhotosListLoading;

  const AppState({@required this.photos, @required this.isPhotosListLoading});

  @override
  String toString() {
    return 'AppState: {photos: $photos}';
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AppState &&
          runtimeType == other.runtimeType &&
          ListEquality().equals(photos, other.photos) &&
          isPhotosListLoading == other.isPhotosListLoading;

  @override
  int get hashCode => photos.hashCode ^ isPhotosListLoading.hashCode;
}
```

We are also overriding `==` (equals) and `hashCode`. Equality will be required when we need to compare states to avoid rendering again when the state has not changed.

Now let's create our reducers. For this we'll need to add the [redux.dart](https://pub.dev/documentation/redux/latest/index.html) package to our `pubspec.yaml`. This package will bring the basic Redux features we need to implement our architecture.

Our `appReducer` is going to be a composition of two different reducers.

```dart
AppState appReducer(AppState state, action) {
  return AppState(
      photos: photosReducer(state.photos, action),
      isPhotosListLoading:
          photosListViewStateReducer(state.isPhotosListLoading, action));
}
```

The `photosReducer` will handle state changes for updating the photos in the `AppState`. It essentially gets the photos passed by the action so we are replacing the complete list. We are being intentionally simple here.

Note that we use `TypedReducer` from `redux.dart` package. `TypedReducer` binds a state change to a given action type, so we can avoid the boilerplate for comparing action types by ourselves. Without this, we would need to have a big switch case where we would compare the `action.runtimeType` with each one of the action types to trigger the proper reducers when required.

We need to pass a function reference (`__updatePhotosReducer`) to call every time the given state needs to be updated.

```dart
final photosReducer =
    TypedReducer<List<Photo>, UpdatePhotosAction>(_updatePhotosReducer);

List<Photo> _updatePhotosReducer(List<Photo> state, UpdatePhotosAction action) {
  return action.photos;
}
```

In the other hand, we have a `photosListViewStateReducer` that will respond to the `TogglePhotosListLoadingAction` for updating the toggle state. The action will pass the new value for it:

```dart
final photosListViewStateReducer =
    TypedReducer<bool, TogglePhotosListLoadingAction>(_togglePhotosListLoading);

bool _togglePhotosListLoading(bool state, TogglePhotosListLoadingAction action) {
  return action.isLoading;
}
```

This is probably a really simple state segregation approach. You could do it in the way that better matches your needs. In this case I am separating what we could consider app state (`photos`) from view state (`isPhotosListLoading`).

If we had more widgets on screen, or multiple screens, we would most likely combine different reducers for the view state for example. You've got `combineReducers()` method for that in the `redux.dart` package.

So we got a way to reduce any state changes for both `UpdatePhotosAction` and `TogglePhotosListLoadingAction`, but what about the actual actions? Well, they're very simple.

```dart
class TogglePhotosListLoadingAction {
  final bool isLoading;

  const TogglePhotosListLoadingAction({this.isLoading});
}


class UpdatePhotosAction {
  final List<Photo> photos;

  const UpdatePhotosAction({this.photos});
}
```

As explained above, actions reflect the need for a state change, and can carry some payload for it, but that's it. Here `TogglePhotosListLoadingAction` reflects the need to toggle the loading state for the photos list screen, so it carries the new state for it that will be used by the reducer. For updating the photos we do the same. We just need to use the new list of photos as a payload.

This sync actions are very simple aren't they?

But there's still an issue. We are able to show / hide a loader by updating it's state. We are also able to render a list of photos by following the state updated by `UpdatePhotosAction`. But **who's fetching the photos?**
