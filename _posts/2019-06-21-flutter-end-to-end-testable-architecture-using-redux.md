---
layout: post
current: post
cover: assets/images/taj.jpg
navigation: True
title: Flutter - Testable architecture using Redux
date: 2019-06-21 12:15:00
tags: [flutter,architecture]
class: post-template
subclass: 'post'
author: jorge
---

Architecture concepts are often common across platforms. Let's learn how to build an end to end architecture for Flutter using Redux. Our main focus will be testability. âœ…

### Unidireccional data flow

This is something we've heard many times already, so let me point very rapidly the key points of an architecture like Redux which implements this pattern. The most basic diagram for Redux might look like this:

![redux](assets/images/redux.png)

Let's go briefly over all the pieces:

* **View**: The rendering side of the program. Our Widget tree in Flutter. It dispatches actions on start or as the result of user interactions.
* **Action**: The intent of changing state. Usually called after verbs that reflect that intent. E.g: *UpdatePhotos*, *ToggleLoading*, or even *RouteToPhotoDetail*. (Because why not? The current displayed screen could also be part of the app state)
* **Reducer**: Reducers are **pure functions** with the form `AppState appReducer(AppState state, action)`. So they take the current app state and an action, apply the changes required by the action and return **a new app state**.
* **Store**: Where the app state is. The state generated by reducers is stored here. A state change in the `Store` triggers a `View` redraw. So the `Widgets` directly affected will redraw themselves to match the new state.

As you can see, events flow in a single direction. On top of that, I'd like to remark the following details from a holistic point of view:

* The app has a single source of truth, the state. That doesn't mean you can't **compose that state for better concern separation**, e.g: having one substate per screen, or split view and app state. The important bit here is that the state is composed and unique, so we can render our app at any point in time just by feeding it a current snapshot of the state.
* Having state as a single source of truth allows you to serialize it, send it over network and restore it in a different machine, which allows you to reproduce any app state for debugging purposes, shortcut development workflows, share development scenarios with your team mates, and much more.
* **State is immutable**. It goes from a previous state to a new state through reducers and actions as described above. State is replaced by the new one, never mutated. That's key so we can ensure the only state change occurring in the app is done by the reducers.
* Immutable state allows us to compare different snaphots of the state for optimizing the rendering phase (you don't need to render again a Widget when its state remains unchanged).
* It usually comes handy to override `toString()` in the state, so you can easily log it during development, or send it to a tracking system.
* In some not statically typed languages, actions carry a `type` field or property to determine their intent. Given we've got classes here we can just reflect that intent by the action class name.
* Actions can contain a payload as the required data to perform a state change. So the reducer gets an action, extracts the payload and uses it to perform the required state update.
* Actions are also immutable.
* When we say "reducers are *pure functions*", we mean they just take their input arguments (current app state + action) and generate a new app state. They don't try to access anything in the external world.
* It's recommendable to split and compose reducers, so your global reducer is a composition of minor reducers intentionally segregated to cover different domain areas or different parts of the state tree.
* If you are able to log / serialize / persist / track actions and state, then you're literally able to reproduce how users get to a given scenario, since any app state is the result of the initial app state plus all the actions applied on top of it. In other words, you can fast forward state, rewind state, or reproduce any state snapshot.
* When state is immutable and state changes work like a state machine, your program becomes deterministic. That means you can reason about it in a considerably easier way.
* When state is deterministic you can create advanced tooling for developers that leverages app state inspection hence debugging capabilities.

Let's come back down to earth and jump into a practical example now.

### Wallpapers app

This is gonna be a very simple app for the sake of the example. We essentially want to load a bunch of wallpapers from a service and show a loader in the meantime, like this:

![wallpapers app](assets/images/wallpapers_app.gif){:height="712px"}

So this screen will have 2 different states: A list of photos and a boolean determining whether the view is loading or not.

```dart
@immutable
class AppState {
  final List<Photo> photos;
  final bool isPhotosListLoading;

  const AppState({@required this.photos, @required this.isPhotosListLoading});

  @override
  String toString() {
    return 'AppState: {photos: $photos}';
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AppState &&
          runtimeType == other.runtimeType &&
          ListEquality().equals(photos, other.photos) &&
          isPhotosListLoading == other.isPhotosListLoading;

  @override
  int get hashCode => photos.hashCode ^ isPhotosListLoading.hashCode;
}
```

We are also overriding `==` (equals) and `hashCode`. Equality will be required when we need to compare states to avoid rendering again when the state has not changed.

Now let's create our reducers. For this we'll need to add the [redux.dart](https://pub.dev/packages/redux/) package to our `pubspec.yaml`. This package will bring the basic Redux features we need to implement our architecture.

Our `appReducer` is going to be a composition of two different reducers.

```dart
AppState appReducer(AppState state, action) {
  return AppState(
      photos: photosReducer(state.photos, action),
      isPhotosListLoading: photosListViewStateReducer(state.isPhotosListLoading, action));
}
```

The `photosReducer` will handle state changes for updating the photos in the `AppState`. It essentially gets the new photos list passed by the action and replaces the old one in the `Store`. We are being intentionally simple here.

```dart
final photosReducer =
    TypedReducer<List<Photo>, UpdatePhotosAction>(_updatePhotosReducer);

List<Photo> _updatePhotosReducer(List<Photo> state, UpdatePhotosAction action) {
  return action.photos;
}
```

Note that we use `TypedReducer` from [redux.dart](https://pub.dev/packages/redux/) package. `TypedReducer` binds a state change to a given action type, so we can avoid the boilerplate for comparing action types by ourselves. Without this, we would need to have a big switch case where we would compare the `action.runtimeType` with each one of the action types to trigger the proper reducers when required.

We need to pass a function reference (in this case `__updatePhotosReducer`) to call every time an `UpdatePhotosAction` arrives.

In the other hand, we have a `photosListViewStateReducer` that will respond to the `TogglePhotosListLoadingAction` for updating the toggle state. The action will pass the new value for it:

```dart
final photosListViewStateReducer =
    TypedReducer<bool, TogglePhotosListLoadingAction>(_togglePhotosListLoading);

bool _togglePhotosListLoading(bool state, TogglePhotosListLoadingAction action) {
  return action.isLoading;
}
```

This is probably a really simple state segregation approach. You could do it in the way that better matches your needs. In this case I am separating what we could consider app state (`photos`) from view state (`isPhotosListLoading`).

If we had more widgets on screen, or multiple screens, we would most likely combine different reducers for the view state for example. [You've got `combineReducers` method for that in the `redux.dart` package](https://github.com/johnpryan/redux.dart/blob/master/doc/combine_reducers.md#reducing-boilerplate-in-a-type-safe-way).

Logics for reducing a single state can be combined. As a very brief parenthesis, let's say we had a more complex scenario where we needed separate logics for adding or removing photos to/from the list state in the `Store`. We could use `combineReducers` and `TypedReducer` for achieving our goal with just a few lines! ðŸ‘Œ

```dart
Reducer<List<Photo>> photosListViewStateReducer = combineReducers<List<Photo>>([
  new TypedReducer<List<String>, AddPhotoAction>(addItemReducer),
  new TypedReducer<List<String>, RemovePhotoAction>(removeItemReducer),
]);
```
Our state will be reduced by any of those reducers, depending on the action that arrives. `TypedReducers` will do the magic.

Now getting back to our example, we got a way to reduce any state changes for both `UpdatePhotosAction` and `TogglePhotosListLoadingAction`, but what about the actual actions items? We still didn't have a look to those. Well, they're indeed very simple.

```dart
class TogglePhotosListLoadingAction {
  final bool isLoading;

  const TogglePhotosListLoadingAction({this.isLoading});
}


class UpdatePhotosAction {
  final List<Photo> photos;

  const UpdatePhotosAction({this.photos});
}
```

Both actions reflect the need for a state change, and can carry some payload for it.

But there's still an issue. We are able to show / hide a loader and show a list of photos by updating it's state. But **who's fetching the photos?**

That's where a package like [redux_thunk](https://pub.dev/packages/redux_thunk) comes into play. It integrates itself perfectly with `redux.dart`, and it essentially allows you to **write asynchronous actions!**. This will considerably simplify our architecture, since we'll have our actions atomic and as totally swappable items, no matter whether they're sync or async.

Let's say we've got a `PhotosRepository` that abstracts the source of the data in an asynchronous way, so it returns a `Future<List<Photo>>`. We could write a `ThunkAction` (asynchronous action) like the following:

```dart
ThunkAction<AppState> fetchPhotosAction(PhotosRepository repo) {
  return (store) {
    store.dispatch(new TogglePhotosListLoadingAction(isLoading: true));
    repo.getPhotos().then((photos) {
      store.dispatch(new TogglePhotosListLoadingAction(isLoading: false));
      store.dispatch(new UpdatePhotosAction(photos: photos));
    }).catchError((exception) => throw Exception(exception));
  };
}
```

These actions work as **higher order actions** since they dispatch simpler actions inside. In this case we dispatch a `TogglePhotosListLoadingAction` to set the loading state to `true`, then we fetch the photos and whenever that's complete (using `.then` combinator) we dispatch `TogglePhotosListLoadingAction` to set the loading state to false, and `UpdatePhotosAction` to store the fresh photos state.

And with this, one of the only still missing pieces would be to connect the dots in the entry point of our app. Here's our `main` function to run the app.

```dart
void main() {
  final store = Store<AppState>(appReducer,
      initialState: AppState(photos: List(), isPhotosListLoading: false),
      middleware: [
        new LoggingMiddleware.printer(),
        thunkMiddleware
      ]);

  runApp(StoreProvider(store: store, child: DigitalNomadApp()));
}
```

We just need to create our `Store` for the `AppState`, pass in our `appReducer` (that's the root reducer, a combination of all reducers mentioned earlier), an initial value for the state, and **some optional `middlewares`**. Yep, `Middleware` is a new piece here we didn't mention before!

`Middleware` actually lives in between the actions and the reducers and it's used for shortcutting some behaviours for all actions. E.g: We can use a logging middleware so we log all actions that come in and can easily follow state changes during development, or a `thunkMiddleware` for being able to dispatch both sync and async actions transparently so **the `View` layer doesn't need to worry about the differentiation between both**. That's actually a powerful feature.

Here is how the diagram will look now after adding the `Middleware`:

![Redux diagram complete](assets/images/redux2.png)

Final touches: Let's connect our `View` so it dispatches any required actions on `init` or on user interaction, and also reacts automatically to any changes in the `AppState`. That will close the cycle and complete our end to end architecture.

```dart
class DigitalNomadApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Digital Nomad Wallpapers',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: PhotoList(),
    );
  }
}

class PhotoList extends StatefulWidget {
  @override
  _PhotoListState createState() => _PhotoListState();
}

class _PhotoListState extends State<PhotoList> {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
        appBar: AppBar(
          title: Text("Digital Nomad Wallpapers"),
        ),
        backgroundColor: Colors.black,
        body: StoreConnector<AppState, bool>(
            converter: (store) => store.state.isPhotosListLoading,
            onInit: (store) {
              store.dispatch(fetchPhotosAction());
            },
            distinct: true,
            builder: (_, isLoading) {
              return isLoading
                  ? Center(
                      child: CircularProgressIndicator(),
                    )
                  : Padding(
                      padding: EdgeInsets.all(2.0),
                      child: StoreConnector<AppState, List<Photo>>(
                        converter: (store) => store.state.photos,
                        builder: (_, photos) {
                          return GridView.builder(
                            itemCount: photos.length,
                            itemBuilder: (BuildContext context, int index) {
                              final photoUrl = photos[index].portrait;
                              return Padding(
                                padding: EdgeInsets.all(1.0),
                                child: new Image.network(
                                  photoUrl,
                                  fit: BoxFit.cover,
                                ),
                              );
                            },
                            gridDelegate:
                                SliverGridDelegateWithFixedCrossAxisCount(
                                    crossAxisCount: 3, childAspectRatio: 0.6),
                          );
                        },
                      ));
            }));
  }
```

Note how the app looks pretty standard, except for one thing. We're using some `StoreConnector` widgets there. That's where the `View` connects to the `Store` to read from it or dispatch actions to it. It has some key parameters:

* `converter`: This is **just a standard mapper** that maps from the store to the actual state you're interested in at that level. If you have a `StoreConnector<AppState, bool>` like in the root one, you'll map from the `Store` to a `bool` value. We'll use that one to read the loading state.
* `init`: It's natural that you need an optional place to dispatch any actions that don't rely on user interaction, like the one to fetch the list of photos at start. `init` is the place for it, so we can `store.dispatch(fetchPhotosAction())` there.
* `distinct` is a clever guy here. It will make the view render again just when the state has changed from last time. That's why we needed to override `==` (equals) in our `AppState` in the beginning! ðŸ’¡
* `builder`: A plain widget builder that gives you access to the state being listened so you can render your current view using that state.

There's an inner `StoreConnector` for the photos list, let's extract it for clarity:
```dart
StoreConnector<AppState, List<Photo>>(
  converter: (store) => store.state.photos,
  builder: (_, photos) {
    return GridView.builder(
      itemCount: photos.length,
      itemBuilder: (BuildContext context, int index) {
        final photoUrl = photos[index].portrait;
        return Padding(
          padding: EdgeInsets.all(1.0),
          child: new Image.network(
            photoUrl,
            fit: BoxFit.cover,
          ),
        );
      },
      gridDelegate:
          SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 3, childAspectRatio: 0.6),
    );
  },
));
```

On this one we map from the store to `List<Photo>` in the `converter`. We want to listen to that state from our widget builder so we can conveniently render our photos list, which is actually going to be a `Grid`!

![wallpapers app](assets/images/wallpapers_app.gif){:height="712px"}

Et voilÃ ! we got our app up and running. Let's dive into how testable it is now. ðŸ¤”

### Testing
