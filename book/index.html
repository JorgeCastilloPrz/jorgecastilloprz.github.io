<!DOCTYPE html>
<html>
<head>
    
    <link rel="stylesheet" type="text/css" href="/assets/built/style.css" />

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Jetpack Compose internals üìñ</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Fira+Code:500&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Noto+Sans&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Work+Sans&display=swap" rel="stylesheet">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Quicksand&display=swap" rel="stylesheet">

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->

    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="A consciously crafted dive into the Jetpack Compose guts." />
    <link rel="shortcut icon" href="https://jorgecastilloprz.github.io/assets/images/favicon.png" type="image/png" />
    <link rel="canonical" href="https://jorgecastilloprz.github.io/book/" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="üë®‚Äçüíª Jorge Castillo" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Jetpack Compose internals üìñ" />
    <meta property="og:description" content="A consciously crafted dive into the Jetpack Compose guts." />
    <meta property="og:url" content="https://jorgecastilloprz.github.io/book/" />
    <meta property="og:image" content="https://jorgecastilloprz.github.io/assets/images/bookcover.png" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Jetpack Compose internals üìñ" />
    <meta name="twitter:description" content="A consciously crafted dive into the Jetpack Compose guts." />
    <meta name="twitter:url" content="https://jorgecastilloprz.github.io/" />
    <meta name="twitter:image" content="https://jorgecastilloprz.github.io/assets/images/bookcover.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="üë®‚Äçüíª Jorge Castillo" />
    <meta name="twitter:site" content="@jorgecastillopr" />
    <meta name="twitter:creator" content="@jorgecastillopr" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "üë®‚Äçüíª Jorge Castillo",
        "logo": "https://jorgecastilloprz.github.io/"
    },
    "url": "https://jorgecastilloprz.github.io/book/",
    "image": {
        "@type": "ImageObject",
        "url": "https://jorgecastilloprz.github.io/assets/images/blog-cover-dark.png",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://jorgecastilloprz.github.io/book/"
    },
    "description": "A consciously crafted dive into the Jetpack Compose guts."
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Jetpack Compose internals üìñ" href="/feed.xml" />

    <style>
        .highlighter-rouge, .highlight, code {
            width: 100%;
        }
    </style>


</head>
<body class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://jorgecastilloprz.github.io/">üë®‚Äçüíª Jorge Castillo</a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-animations" role="menuitem" style="margin-left: 14px;"><a class="colorWhite" href="/course/">Course üé¨</a></li>
    <li class="nav-androidcourse" style="margin-left: 10px; margin-right: 10px;" role="menuitem"><a class="colorOnHighlight" href="/book/">Book üìñ Jetpack Compose internals üî•</a></li>
    <li class="nav-about" role="menuitem"><a class="menuLink" href="/about/">About</a></li>
</ul>

        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
                <a class="social-link social-link-tw" href="https://twitter.com/jorgecastillopr" target="_blank" rel="noopener"><img width=26 src="../assets/images/twitter.svg"/></a>
            
            
                <a class="social-link social-link-tw" href="https://androiddev.social/@jorge" target="_blank" rel="noopener"><img width=26 src="../assets/images/mastodon.svg"/></a>
            
        </div>
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="innerBig" style="font-family: 'Quicksand', 'Noto Sans', sans-serif;">

        <article class="post-full post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Jetpack Compose internals üìñ</h1>
            </header>

            

            <section class="post-full-content">
                <div class="flex-container-full">
  <div style="flex-grow:1">
    <p style="margin-top:25px;">Do you wonder how Jetpack Compose works internally, or how the compiler or the runtime work together? Are you curious about other use cases for Compose? Did you ever think about how Composable functions communicate with the compiler and the runtime?</p>

    <p>It's your lucky day üôå <b>Jetpack Compose internals</b> is your chance to go one step further and learn the guts of what will become the new standard of Android UI.</p>

   <div class="avatars">
      <span class="avatar">
          <img src="../assets/images/portrait.png" />
      </span>
      <span class="avatar">
          <img src="../assets/images/andrei.png" />
      </span>
      <span class="avatar">
            <img src="../assets/images/enrique.png" />
        </span>
      <span class="avatar">
            <img src="../assets/images/antonioleiva.png" />
        </span>
      <span class="avatar">
            <img src="../assets/images/joeavatar.png" />
        </span>
      <span class="avatar">
          <img src="../assets/images/manuelvivo.png" />
        </span>
    </div>
    <div style="float:none"></div>

    <div class="roundedbutton"><a target="_blank" href="https://leanpub.com/composeinternals/">Get the book</a></div>
    <div class="roundedbuttonYellow"><a target="_blank" href="https://twitter.com/composeinternal/">Follow on Twitter</a></div>
    <div class="freeLabelButton"><a href="#preview">Read chapter 1 for FREE üëÄ</a></div>
    <div class="secondaryButton"><a href="#sponsor">Sponsor the book üëá</a></div>
  </div>
  <div style="flex-grow:1">
    <img src="../assets/images/title_page.png" alt="My portrait pic" style="width:70%;margin-top:10px" />
  </div>
</div>

<hr />

<p><a id="preview" name="preview"></a>
<span style="background-color:#86efac; border-radius: 8px; border: 1px solid #4ade80;padding:8px;">üëÄ FREE content - chapter 1 for free</span></p>

<h2 id="composable-functions"><span style="font-family: 'Quicksand', 'Noto Sans', sans-serif;">Composable functions</span></h2>

<h3 id="the-meaning-of-composable-functions"><span style="font-family: 'Quicksand', 'Noto Sans', sans-serif;">The meaning of Composable functions</span></h3>

<p>Probably the most adequate way to start a book about Jetpack Compose internals would be by learning about Composable functions, given those are the atomic building blocks of Jetpack Compose, and the construct we will use to write our composable trees. I intentionally say ‚Äútrees‚Äù here, since composable functions can be understood as nodes in a larger tree that the Compose runtime will represent in memory. We will get to this in detail when the time comes, but it is good to start growing the correct mindset from the very beginning.
If we focus on plain syntax, any standard Kotlin function can become a Composable function just by annotating it as <code class="language-plaintext highlighter-rouge">@Composable</code>:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Composable</span>
<span class="k">fun</span> <span class="nf">NamePlate</span><span class="p">(</span><span class="n">name</span><span class="p">:</span><span class="nc">String</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Our composable code </span>
<span class="p">}</span>
</code></pre></div></div>

<p>By doing this we are essentially telling the compiler that the function intends to convert some data into a node to register in the composable tree. That is, if we read a Composable function as <code class="language-plaintext highlighter-rouge">@Composable (Input) -&gt; Unit</code>, the input would be the data, and the output would not be a value returned from the function as most people would think, but an action registered to insert the element into the tree. We could say that this happens as a side effect of executing the function.</p>

<blockquote>
  <p>Note how returning <code class="language-plaintext highlighter-rouge">Unit</code> from a function that takes an input means we are likely consuming that input somehow within the body of the function.</p>
</blockquote>

<p>The described action is usually known as ‚Äúemitting‚Äù in the Compose jargon. Composable functions emit when executed, and that happens during the composition process. We will learn every detail about this process in the upcoming chapters. For the time being, every time we read something about ‚Äúcomposing‚Äù a Composable function, let‚Äôs simply think of it as an equivalent of ‚Äúexecuting‚Äù it.</p>

<p><img src="../assets/images/composable_function.png" alt="Composable function emits image" /></p>

<p>The only purpose of executing our Composable functions is to build or update the in-memory representation of the tree. That will keep it always up to date with the structure it represents, since Composable functions will re-execute whenever the data they read changes. To keep the tree updated, they can emit actions to insert new nodes as explained above, but they can also remove, replace, or move nodes around. Composable functions can also read or write state from/to the tree.</p>

<h2 id="properties-of-composable-functions">Properties of Composable functions</h2>

<p>There are other relevant implications of annotating a function as Composable. The <code class="language-plaintext highlighter-rouge">@Composable</code> annotation effectively <strong>changes the type of the function</strong> or expression that it is applied to, and as any other type, it imposes some constraints or properties over it. These properties are very relevant to Jetpack Compose since they unlock the library capabilities.</p>

<p>The Compose runtime expects Composable functions to comply to the mentioned properties, so it can assume certain behaviors and therefore exploit different runtime optimizations like parallel composition, arbitrary order of composition based on priorities, smart recomposition, or positional memoization among others. But please, don‚Äôt feel overwhelmed about all these new concepts yet, we will dive into every single one in depth at the right time.</p>

<blockquote>
  <p>Generically speaking, runtime optimizations are only possible when a runtime can have some certainties about the code it needs to run, so it can assume specific conditions and behaviors from it. This unlocks the chance to execute, or in other words ‚Äúconsume‚Äù this code following different execution strategies or evaluation techniques that take advantage of the mentioned certainties.</p>

  <p>An example of these certainties could be the relation between the different elements in code. Are they dependant on each other or not? Can we run them in parallel or different order without affecting the program result? Can we interpret each atomic piece of logic as a completely isolated unit?</p>
</blockquote>

<p>Let‚Äôs learn about the properties of Composable functions.</p>

<h2 id="calling-context">Calling context</h2>

<p>Most of the properties of Composable functions are enabled by the Compose compiler. Since it is a Kotlin compiler plugin, it runs during the normal compiler phases, and has access to all the information that the Kotlin compiler has access to. This allows it to intercept and transform the IR (intermediate representation) of all the Composable functions from our sources in order to add some extra information to them.</p>

<p>One of the things added to each Composable function is a new parameter, at the end of the parameters list: The <code class="language-plaintext highlighter-rouge">Composer</code>. This parameter is implicit, the developer remains agnostic of it. An instance of it is injected at runtime, and forwarded to all the child Composable calls so it is accessible from all levels of the tree.</p>

<p><img src="../assets/images/calling_context.png" alt="Calling context" /></p>

<p>In code, let‚Äôs say we have the following Composable:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Composable</span>
<span class="k">fun</span> <span class="nf">NamePlate</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nc">String</span><span class="p">,</span> <span class="n">lastname</span><span class="p">:</span> <span class="nc">String</span><span class="p">)</span> <span class="p">{</span>
  <span class="nc">Column</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="nc">Modifier</span><span class="p">.</span><span class="nf">padding</span><span class="p">(</span><span class="mi">16</span><span class="p">.</span><span class="n">dp</span><span class="p">))</span> <span class="p">{</span>
    <span class="nc">Text</span><span class="p">(</span><span class="n">text</span> <span class="p">=</span> <span class="n">name</span><span class="p">)</span>
    <span class="nc">Text</span><span class="p">(</span><span class="n">text</span> <span class="p">=</span> <span class="n">lastname</span><span class="p">,</span> <span class="n">style</span> <span class="p">=</span> <span class="nc">MaterialTheme</span><span class="p">.</span><span class="n">typography</span><span class="p">.</span><span class="n">subtitle1</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The Compiler will transform it into something like this:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">NamePlate</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nc">String</span><span class="p">,</span> <span class="n">lastname</span><span class="p">:</span> <span class="nc">String</span><span class="p">,</span> <span class="err">$</span><span class="n">composer</span><span class="p">:</span> <span class="nc">Composer</span><span class="p">&lt;</span><span class="err">*</span><span class="p">&gt;)</span> <span class="p">{</span>
  <span class="o">..</span><span class="p">.</span>
  <span class="nc">Column</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="nc">Modifier</span><span class="p">.</span><span class="nf">padding</span><span class="p">(</span><span class="mi">16</span><span class="p">.</span><span class="n">dp</span><span class="p">),</span> <span class="err">$</span><span class="n">composer</span><span class="p">)</span> <span class="p">{</span>
    <span class="nc">Text</span><span class="p">(</span> 
      <span class="n">text</span> <span class="p">=</span> <span class="n">name</span><span class="p">,</span>
      <span class="err">$</span><span class="n">composer</span>
    <span class="p">)</span>
    <span class="nc">Text</span><span class="p">(</span>
      <span class="n">text</span> <span class="p">=</span> <span class="n">lastname</span><span class="p">,</span>
      <span class="n">style</span> <span class="p">=</span> <span class="nc">MaterialTheme</span><span class="p">.</span><span class="n">typography</span><span class="p">.</span><span class="n">subtitle1</span><span class="p">,</span>
      <span class="err">$</span><span class="n">composer</span>
    <span class="p">)</span>
  <span class="p">}</span>
  <span class="o">..</span><span class="p">.</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As we can see, the <code class="language-plaintext highlighter-rouge">Composer</code> is forwarded to all the Composable calls within the body. On top of this, the Compose compiler imposes a strict rule to Composable functions: They can only be called from other Composable functions. This is the actual <strong>calling context</strong> required, and it ensures that the tree is conformed of only Composable functions, so the <code class="language-plaintext highlighter-rouge">Composer</code> can be forwarded down.</p>

<p>The <code class="language-plaintext highlighter-rouge">Composer</code> is the connection between the Composable code we write as developers, and the Compose runtime. Composable functions will use it to emit their changes for the tree and therefore inform the runtime about its shape in order to build its in-memory representation or update it.</p>

<div style="border:2px dashed #cbd5e1;padding:20px;border-radius:8px;background-color:#f8fafc">
  <div class="grid gap-4 grid-cols-1 md:grid-cols-1 lg:grid-cols-2 xl:grid-cols-2">
    <div>
      <h2>Take the online course and join the exclusive community</h2>
      <div class="w-1/2 xs:text-start sm:text-start md:text-start text-start">
        <div class="avatars">
          <span class="avatar">
              <img src="../assets/images/paulfrancoavatar.jpeg" />
          </span>
          <span class="avatar">
              <img src="../assets/images/bkinyaavatar.jpeg" />
          </span>
          <span class="avatar">
                <img src="../assets/images/franciscovelazquezavatar.jpeg" />
            </span>
          <span class="avatar">
                <img src="../assets/images/aurelioavatar.jpeg" />
            </span>
          <span class="avatar">
                <img src="../assets/images/tashaavatar.jpeg" />
            </span>
          <span class="avatar">
              <img src="../assets/images/annyceavatar.jpeg" />
            </span>
        </div>
      </div>
    
      <p>Master Jetpack Compose and learn how to work efficiently with it by taking this course. Enjoy the perfect mix of theory and exercises with the best trainer ‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è</p>
      <div class="flex">
        <img class="flex-initial w-24 h-24" style="margin-right:16px; margin-top:8px; width: auto;" src="../assets/images/gdeavatar.png" />
        <span class="flex-auto">
        Created and delivered by Jorge Castillo, Google Developer Expert for Android and Kotlin
        </span>
      </div>
    </div>
    <div>
      <img src="../assets/images/logos.png" class="logos course-content-image" />
    </div>
  </div>
  <div class="mt-6">
    <a class="float-left font-recoleta blackBtnLarge" target="_blank" href="https://composeinternals.com/">Tell me more üöÄ</a>
    <a class="float-left font-recoleta transparentBtnLarge" target="_blank" href="https://composeinternals.com/#testimonials">Opinions from previous attendees</a>
  </div>
</div>

<h2 id="idempotent">Idempotent</h2>

<p>Composable functions are expected to be idempotent relative to the node tree they produce. Re-executing a Composable function multiple times using the same input parameters should result in the same tree. The Jetpack Compose runtime relies on this assumption for things like recomposition.</p>

<p>In Jetpack Compose, <strong>recomposition</strong> is the action of re-executing Composable functions when their inputs vary, so they can emit updated information and update the tree. The runtime must have the ability to recompose our Composable functions at arbitrary times, and for diverse reasons.</p>

<p>The recomposition process traverses down the tree checking which nodes need to be recomposed (re-executed). Only the nodes with varying inputs will recompose, and the rest will be <strong>skipped</strong>. Skipping a node is only possible when the Composable function representing it is idempotent, since the runtime can assume that given the same input, it will produce the same results. Those results are already in-memory, hence Compose does not need to re-execute it.</p>

<div class="roundedbutton"><a target="_blank" href="https://leanpub.com/composeinternals/">Buy Jetpack Compose internals üí∏</a></div>

<h2 id="free-of-uncontrolled-side-effects">Free of uncontrolled side effects</h2>

<p>A side effect is any action that escapes the control of the function where it is called in order to do something unexpected on the side. Things like reading from a local cache, making a network call, or setting a global variable are considered side effects. They make the calling function dependant on external factors that might influence its behavior: external state that might be written from other threads, third party apis that might throw, etc. In other words, the function does not depend on its inputs only to produce a result.</p>

<p>Side effects are <strong>a source of ambiguity</strong>. That is not great for Compose, since the runtime expects Composable functions to be predictable (deterministic), so they can be re-executed multiple times safely. If a Composable function ran side effects, it could produce a different program state on every execution, making it not idempotent.</p>

<p>Let‚Äôs imagine that we ran a network request directly from the body of a Composable function, like this:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Composable</span>
<span class="k">fun</span> <span class="nf">EventsFeed</span><span class="p">(</span><span class="n">networkService</span><span class="p">:</span> <span class="nc">EventsNetworkService</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">val</span> <span class="py">events</span> <span class="p">=</span> <span class="n">networkService</span><span class="p">.</span><span class="nf">loadAllEvents</span><span class="p">()</span>

  <span class="nc">LazyColumn</span> <span class="p">{</span>
    <span class="nf">items</span><span class="p">(</span><span class="n">events</span><span class="p">)</span> <span class="p">{</span> <span class="n">event</span> <span class="p">-&gt;</span>
      <span class="nc">Text</span><span class="p">(</span><span class="n">text</span> <span class="p">=</span> <span class="n">event</span><span class="p">.</span><span class="n">name</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This would be very risky, since this function might get re-executed multiple times in a short period of time by the Compose runtime, making the network request trigger multiple times and spiral out of control. It is actually worse than that, since those executions might happen from different threads without any coordination.</p>

<blockquote>
  <p>The Compose runtime reserves the right to pick the execution strategies for our Composable functions. It can offload recompositions to different threads to take advantage of multiple cores, or run them in any arbitrary order based on its own needs or priorities (E.g: Composables not showing on screen could get assigned a lower priority).</p>
</blockquote>

<p>Another common caveat of side effects is that we could make a Composable function depend on the result of another Composable function, imposing a relation of order. That should be avoided at all cost. An example of this:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Composable</span>
<span class="k">fun</span> <span class="nf">MainScreen</span><span class="p">()</span> <span class="p">{</span>
  <span class="nc">Header</span><span class="p">()</span>
  <span class="nc">ProfileDetail</span><span class="p">()</span>
  <span class="nc">EventList</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In this snippet, <code class="language-plaintext highlighter-rouge">Header</code>, <code class="language-plaintext highlighter-rouge">ProfileDetail</code> and <code class="language-plaintext highlighter-rouge">EventList</code> might execute in any order, or even in parallel. We should not write logics that assume any specific execution order, like reading an external variable from <code class="language-plaintext highlighter-rouge">ProfileDetail</code> that is expected to be written from <code class="language-plaintext highlighter-rouge">Header</code>.</p>

<p>Generically speaking, side effects are not ideal in Composable functions. We must try making all our Composable functions stateless, so they get all their inputs as parameters, and only use them to produce a result. This makes Composables simpler, dumber, and highly reusable. However, side effects are needed to write stateful programs, so at some level we will need to run them (frequently at the root of our Composable tree). Programs need to run network requests, persist information in databases, use memory caches, etc. For this reason, Jetpack Compose offers mechanisms to call effects from Composable functions safely and within a controlled environment: The <strong>effect handlers</strong>.</p>

<p>Effect handlers make side effects aware of the Composable lifecycle, so they can be constrained/driven by it. They allow effects to be automatically disposed/canceled when the Composable leaves the tree, re-triggered if the effect inputs change, or even span the same effect across executions (recompositions) so it is only called once. We will cover effect handlers in detail in later chapters. They will allows us to avoid calling effects directly from the Composable‚Äôs body without any control.</p>

<h2 id="restartable">Restartable</h2>

<p>We have mentioned this a few times already. Composable functions can recompose, so they are not like standard functions, in the sense that they will not be called only once as part of a call stack. This is how a normal call stack would look. Each function gets called once, and it can call one or multiple other functions.</p>

<p><img src="../assets/images/restartable1.png" alt="Restartable 1" /></p>

<p>On the other hand, Composable functions can be restarted (re-executed, recomposed) multiple times, so the runtime keeps a reference to them in order to do so. Here is how a Composable call tree could look:</p>

<p><img src="../assets/images/restartable2.png" alt="Restartable 2" /></p>

<p>Composables 4 and 5 are re-executed after their inputs change.</p>

<p>Compose is selective about which nodes of the tree to restart in order to keep its in-memory representation always up to date. Composable functions are designed to be reactive and re-executed based on changes in the state they observe.</p>

<p>The Compose compiler finds all Composable functions that read some state and generates the code required to teach the runtime how to restart them. Composables that don‚Äôt read state don‚Äôt need to be restarted, so there is no reason to teach the runtime how to do so.</p>

<h2 id="fast-execution">Fast execution</h2>

<p>We can think of Composable functions and the Composable function tree as a fast, declarative, and lightweight approach to build a description of the program that will be retained in memory and interpreted / materialized in a later stage.</p>

<p>Composable functions don‚Äôt build and return UI. They simply emit data to build or update an in-memory structure. That makes them blazing fast, and allows the runtime to execute them multiple times without fear. Sometimes it happens very frequently, like for every frame of an animation.</p>

<p>Developers must fulfill this expectation when writing code. Any cost heavy computation should be offloaded to coroutines and always wrapped into one of the lifecycle aware effect handlers that we will learn about ahead in this book.</p>

<h2 id="positional-memoization">Positional memoization</h2>

<p>Positional memoization is a form of function memoization. Function memoization is the ability of a function to cache its result based on its inputs, so it does not need to be computed again every time the function is called for the same inputs. As we already learned, that is only possible for pure (<strong>deterministic</strong>) functions, since we have the certainty that they will always return the same result for the same inputs, hence we can cache and reuse the value.</p>

<blockquote>
  <p>Function memoization is a technique widely known in the Functional Programming paradigm, where programs are defined as a composition of pure functions.</p>
</blockquote>

<p>In function memoization, a function call can be identified through a combination of its name, type, and parameter values. A unique key can be created using those elements, and used to store/index/read the cached result in later calls. In Compose, an additional element is considered: Composable functions have constant knowledge about <strong>their location in the sources</strong>. The runtime will generate different ids (unique within the parent) when the same function is called with the same parameter values but from different places:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Composable</span>
<span class="k">fun</span> <span class="nf">MyComposable</span><span class="p">()</span> <span class="p">{</span>
  <span class="nc">Text</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">)</span> <span class="c1">// id 1</span>
  <span class="nc">Text</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">)</span> <span class="c1">// id 2</span>
  <span class="nc">Text</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">)</span> <span class="c1">// id 3</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The in-memory tree will store three different instances of it, each one with a different identity.</p>

<p><img src="../assets/images/positional_memoization.png" alt="Positional memoization" /></p>

<p>Composable identity is preserved across recompositions, so the runtime can appeal to this structure to know whether a Composable was called previously, and skip it if possible.</p>

<p>Sometimes assigning unique identities can be hard for the Compose runtime. One example is lists of Composables generated from a loop:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Composable</span>
<span class="k">fun</span> <span class="nf">TalksScreen</span><span class="p">(</span><span class="n">talks</span><span class="p">:</span> <span class="nc">List</span><span class="p">&lt;</span><span class="nc">Talk</span><span class="p">&gt;)</span> <span class="p">{</span>
  <span class="nc">Column</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">talk</span> <span class="k">in</span> <span class="n">talks</span><span class="p">)</span> <span class="p">{</span>
      <span class="nc">Talk</span><span class="p">(</span><span class="n">talk</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In this case, <code class="language-plaintext highlighter-rouge">Talk(talk)</code> is called from the same position every time, but each talk represents a different item on the list, and therefore a different node on the tree. In cases like this, the Compose runtime relies on the <strong>order of calls</strong> to generate the unique id, and still be able to differentiate them. This works nicely when adding a new element to the end of the list, since the rest of the calls stay in the same position as before. But what if we added elements to the top, or somewhere in the middle? The runtime would recompose all the <code class="language-plaintext highlighter-rouge">Talk</code>s below that point since they shifted their position, even if their inputs have not changed. This is highly inefficient (esp. for long lists), since those calls should have been skipped.</p>

<p>To solve this, Compose provides the <code class="language-plaintext highlighter-rouge">key</code> Composable, so we can assign an explicit key to the call manually:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Composable</span>
<span class="k">fun</span> <span class="nf">TalksScreen</span><span class="p">(</span><span class="n">talks</span><span class="p">:</span> <span class="nc">List</span><span class="p">&lt;</span><span class="nc">Talk</span><span class="p">&gt;)</span> <span class="p">{</span>
  <span class="nc">Column</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">talk</span> <span class="k">in</span> <span class="n">talks</span><span class="p">)</span> <span class="p">{</span>
      <span class="nf">key</span><span class="p">(</span><span class="n">talk</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Unique key</span>
        <span class="nc">Talk</span><span class="p">(</span><span class="n">talk</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In this example we are using the talk id (likely unique) as the key for each <code class="language-plaintext highlighter-rouge">Talk</code>, which will allow the runtime to preserve the identity of all the items on the list <strong>regardless of their position</strong>.</p>

<p>Positional memoization allows the runtime to remember Composable functions by design. Any Composable function inferred as restartable by the Compose compiler should also be skippable, hence <strong>automatically remembered</strong>. Compose is built on top of this mechanism.</p>

<p>Sometimes developers need to appeal to this in-memory structure in a more granular way than the scope of a Composable function. Let‚Äôs say we wanted to cache the result of a heavy calculation that takes place within a Composable function. The Compose runtime provides the <code class="language-plaintext highlighter-rouge">remember</code> function for that matter:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Composable</span>
<span class="k">fun</span> <span class="nf">FilteredImage</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nc">String</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">val</span> <span class="py">filters</span> <span class="p">=</span> <span class="nf">remember</span> <span class="p">{</span> <span class="nf">computeFilters</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="p">}</span>
  <span class="nc">ImageWithFiltersApplied</span><span class="p">(</span><span class="n">filters</span><span class="p">)</span>
<span class="p">}</span>

<span class="nd">@Composable</span>
<span class="k">fun</span> <span class="nf">ImageWithFiltersApplied</span><span class="p">(</span><span class="n">filters</span><span class="p">:</span> <span class="nc">List</span><span class="p">&lt;</span><span class="nc">Filter</span><span class="p">&gt;)</span> <span class="p">{</span>
  <span class="nc">TODO</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here, we use <code class="language-plaintext highlighter-rouge">remember</code> to cache the result of an operation to precompute the filters of an image. The key for indexing the cached value will be based on the call position in the sources, and also the function input, which in this case is the file path. The <code class="language-plaintext highlighter-rouge">remember</code> function is just a Composable function that knows how to read from and write to the in-memory structure that holds the state of the tree. It only exposes this ‚Äúpositional memoization‚Äù mechanism to the developer.</p>

<p>In Compose, memoization is not application-wide. When something is memoized, it is done within the context of the Composable calling it. In the example from above, it would be <code class="language-plaintext highlighter-rouge">FilteredImage</code>. In practice, Compose will go to the in-memory structure and look for the value in the range of slots where the information for the enclosing Composable is stored. This makes it be more like <strong>a singleton within that scope</strong>. If the same Composable was called from a different parent, a new instance of the value would be returned.</p>

<div class="roundedbutton"><a target="_blank" href="https://leanpub.com/composeinternals/">Buy Jetpack Compose internals üí∏</a></div>

<h2 id="similarities-with-suspend-functions">Similarities with suspend functions</h2>

<p>Kotlin <code class="language-plaintext highlighter-rouge">suspend</code> functions can only be called from other <code class="language-plaintext highlighter-rouge">suspend</code> functions, so they also require a calling context. This ensures that <code class="language-plaintext highlighter-rouge">suspend</code> functions can only be chained together, and gives the Kotlin compiler the chance to inject and forward a runtime environment across all the computation levels. This runtime is added to each <code class="language-plaintext highlighter-rouge">suspend</code> function as an extra parameter at the end of the parameters list: The <code class="language-plaintext highlighter-rouge">Continuation</code>. This paremeter is also implicit, so developers can remain agnostic of it. The <code class="language-plaintext highlighter-rouge">Continuation</code> is used to unlock some new powerful features in the language.</p>

<p>Sounds familiar, right?</p>

<blockquote>
  <p>In the Kotlin coroutine system, a <code class="language-plaintext highlighter-rouge">Continuation</code> is like a callback. It tells the program how to continue the execution.</p>
</blockquote>

<p>Here is an example. A code like the following:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">suspend</span> <span class="k">fun</span> <span class="nf">publishTweet</span><span class="p">(</span><span class="n">tweet</span><span class="p">:</span> <span class="nc">Tweet</span><span class="p">):</span> <span class="nc">Post</span> <span class="p">=</span> <span class="o">..</span><span class="p">.</span>
</code></pre></div></div>

<p>Is replaced by the Kotlin compiler with:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">publishTweet</span><span class="p">(</span><span class="n">tweet</span><span class="p">:</span> <span class="nc">Tweet</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="nc">Continuation</span><span class="p">&lt;</span><span class="nc">Post</span><span class="p">&gt;):</span> <span class="nc">Unit</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">Continuation</code> carries all the information that the Kotlin runtime needs to suspend and resume execution from the different suspension points in our program. This makes <code class="language-plaintext highlighter-rouge">suspend</code> another good example of how requiring a calling context can serve as a means for carrying implicit information across the execution tree. Information that can be used at runtime to enable advanced language features.</p>

<p>In the same way, we could also understand <code class="language-plaintext highlighter-rouge">@Composable</code> as a language feature. It makes standard Kotlin functions restartable, reactive, etc.</p>

<blockquote>
  <p>A fair question to make at this point is why the Jetpack Compose team didn‚Äôt use <code class="language-plaintext highlighter-rouge">suspend</code> for achieving their wanted behavior. Well, even if both features are really similar in the pattern they implement, both are enabling completely different features in the language.</p>

  <p>The <code class="language-plaintext highlighter-rouge">Continuation</code> interface is very specific about suspending and resuming execution, so it is modeled as a callback interface, and Kotlin generates a default implementation for it with all the required machinery to do the jumps, coordinate the different suspension points, share data between them, and so on. The Compose use case is very different, since its goal is to create an in memory representation of a large call graph that can be optimized at runtime in different ways.</p>
</blockquote>

<p>Once we understand the similarities between Composable and suspend functions, it can be interesting to reflect on the idea of ‚Äúfunction coloring‚Äù.</p>

<div style="border:2px dashed #cbd5e1;padding:20px;border-radius:8px;background-color:#f8fafc">
  <div class="grid gap-4 grid-cols-1 md:grid-cols-1 lg:grid-cols-2 xl:grid-cols-2">
    <div>
      <h2>Take the online course and join the exclusive community</h2>
      <div class="w-1/2 xs:text-start sm:text-start md:text-start text-start">
        <div class="avatars">
          <span class="avatar">
              <img src="../assets/images/paulfrancoavatar.jpeg" />
          </span>
          <span class="avatar">
              <img src="../assets/images/bkinyaavatar.jpeg" />
          </span>
          <span class="avatar">
                <img src="../assets/images/franciscovelazquezavatar.jpeg" />
            </span>
          <span class="avatar">
                <img src="../assets/images/aurelioavatar.jpeg" />
            </span>
          <span class="avatar">
                <img src="../assets/images/tashaavatar.jpeg" />
            </span>
          <span class="avatar">
              <img src="../assets/images/annyceavatar.jpeg" />
            </span>
        </div>
      </div>
    
      <p>Master Jetpack Compose and learn how to work efficiently with it by taking this course. Enjoy the perfect mix of theory and exercises with the best trainer ‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è</p>
      <div class="flex">
        <img class="flex-initial w-24 h-24" style="margin-right:16px; margin-top:8px; width: auto;" src="../assets/images/gdeavatar.png" />
        <span class="flex-auto">
        Created and delivered by Jorge Castillo, Google Developer Expert for Android and Kotlin
        </span>
      </div>
    </div>
    <div>
      <img src="../assets/images/logos.png" class="logos course-content-image" />
    </div>
  </div>
  <div class="mt-6">
    <a class="float-left font-recoleta blackBtnLarge" target="_blank" href="https://composeinternals.com/">Tell me more üöÄ</a>
    <a class="float-left font-recoleta transparentBtnLarge" target="_blank" href="https://composeinternals.com/#testimonials">Opinions from previous attendees</a>
  </div>
</div>

<h2 id="the-color-of-composable-functions">The color of Composable functions</h2>

<p>Composable functions have different limitations and capabilities than standard functions. They have a different type (more on this later), and model a very specific concern. This differentiation can be understood as a form of ‚Äúfunction coloring‚Äù, since somehow they represent a separate <strong>category of functions</strong>.</p>

<p>‚ÄúFunction coloring‚Äù is a concept explained by Bob Nystrom from the Dart team at Google in a blockpost called <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">‚ÄúWhat color is your function?‚Äù</a>, written in 2015. He explained how async and sync functions don‚Äôt compose well together, since you cannot call async functions from sync ones, unless you make the latter also async, or provide an awaiting mechanism that allows to call async functions and await for their result. This is why Promises and <code class="language-plaintext highlighter-rouge">async/await</code> were introduced by some libraries and languages. It was an attempt to bring composability back. Bob refers to these two function categories as two different ‚Äúfunction colors‚Äù.</p>

<p>In Kotlin, <code class="language-plaintext highlighter-rouge">suspend</code> aims to solve the same problem. However, <code class="language-plaintext highlighter-rouge">suspend</code> functions are also colored, since we can only call <code class="language-plaintext highlighter-rouge">suspend</code> functions from other <code class="language-plaintext highlighter-rouge">suspend</code> functions. Composing programs with a mix of standard and <code class="language-plaintext highlighter-rouge">suspend</code> functions requires some ad-hoc integration mechanism (coroutine launch points). The integration is not transparent to the developer.</p>

<p>Overall, this limitation is expected. We are modeling two categories of functions that represent concepts of a very different nature. It‚Äôs like speaking two different languages. We have operations that are meant to calculate an immediate result (sync), and operations that unfold over time and eventually provide a result (async), which will likely take longer to complete.</p>

<p>In Jetpack Compose, the case of Composable functions is equivalent. We cannot call Composable functions from standard functions transparently. If we want to do that, an integration point is required (e.g: <code class="language-plaintext highlighter-rouge">Composition.setContent</code>). Composable functions have a completely different goal than standard functions. They are not designed to write program logics, but to describe changes for a node tree.</p>

<p>It might seem that I am tricking a bit here. One of the benefits of Composable functions is that you can declare UI using logics, actually. That means sometimes we need to call Composable functions from standard functions. For example:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Composable</span>
<span class="k">fun</span> <span class="nf">SpeakerList</span><span class="p">(</span><span class="n">speakers</span><span class="p">:</span> <span class="nc">List</span><span class="p">&lt;</span><span class="nc">Speaker</span><span class="p">&gt;)</span> <span class="p">{</span>
  <span class="nc">Column</span> <span class="p">{</span>
    <span class="n">speakers</span><span class="p">.</span><span class="nf">forEach</span> <span class="p">{</span>
      <span class="nc">Speaker</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">Speaker</code> Composable is called from the <code class="language-plaintext highlighter-rouge">forEach</code> lambda, and the compiler does not seem to complain. How is it possible to mix function colors this way then?</p>

<p>The reason is <code class="language-plaintext highlighter-rouge">inline</code>. Collection operators are declared as <code class="language-plaintext highlighter-rouge">inline</code>, so they inline their lambdas into their callers making it effectively as if there was no extra indirection. In the above example, the <code class="language-plaintext highlighter-rouge">Speaker</code> Composable call is inlined within the <code class="language-plaintext highlighter-rouge">SpeakerList</code> body, and that is allowed since both are Composable functions. By leveraging <code class="language-plaintext highlighter-rouge">inline</code> we can bypass the problem of function coloring to write the logic of our Composables. Our tree will be comprised of Composable functions only.</p>

<p>But, is coloring really a problem?</p>

<p>Well, it might be if we needed to combine both types of functions and jump from one to the other all the time. However, that is not the case either for <code class="language-plaintext highlighter-rouge">suspend</code> or <code class="language-plaintext highlighter-rouge">@Composable</code>. Both mechanisms require an integration point, and therefore we gain a completely colored call stack beyond that point (everything <code class="language-plaintext highlighter-rouge">suspend</code>, or Composable). This is actually an advantage, since it allows the compiler and runtime to treat colored functions differently, and enable more advanced language features that were not possible with standard functions.</p>

<p>In Kotlin, <code class="language-plaintext highlighter-rouge">suspend</code> allows to model async non-blocking programs in a very idiomatic and expressive manner. The language gains the ability to represent a very complex concept in an extremely simple way: adding a <code class="language-plaintext highlighter-rouge">suspend</code> modifier to our functions. On the other hand, <code class="language-plaintext highlighter-rouge">@Composable</code> makes standard functions become restartable, skippable, and reactive, which are capabilities that standard Kotlin functions do not have.</p>

<h2 id="composable-function-types">Composable function types</h2>

<p>The <code class="language-plaintext highlighter-rouge">@Composable</code> annotation effectively changes the type of the function at compile time. From a syntax perspective, the type of a Composable function is <code class="language-plaintext highlighter-rouge">@Composable (T) -&gt; A</code>, where <code class="language-plaintext highlighter-rouge">A</code> can be <code class="language-plaintext highlighter-rouge">Unit</code>, or any other type if the function returns a value (e.g: <code class="language-plaintext highlighter-rouge">remember</code>). Developers can use that type to declare Composable lambdas as one would declare any standard lambda in Kotlin.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This can be reused from any Composable tree</span>
<span class="kd">val</span> <span class="py">textComposable</span><span class="p">:</span> <span class="nd">@Composable</span> <span class="p">(</span><span class="nc">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nc">Unit</span> <span class="p">=</span> <span class="p">{</span>
  <span class="nc">Text</span><span class="p">(</span>
    <span class="n">text</span> <span class="p">=</span> <span class="n">it</span><span class="p">,</span>
    <span class="n">style</span> <span class="p">=</span> <span class="nc">MaterialTheme</span><span class="p">.</span><span class="n">typography</span><span class="p">.</span><span class="n">subtitle1</span>
  <span class="p">)</span>
<span class="p">}</span>

<span class="nd">@Composable</span>
<span class="k">fun</span> <span class="nf">NamePlate</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nc">String</span><span class="p">,</span> <span class="n">lastname</span><span class="p">:</span> <span class="nc">String</span><span class="p">)</span> <span class="p">{</span>
  <span class="nc">Column</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="nc">Modifier</span><span class="p">.</span><span class="nf">padding</span><span class="p">(</span><span class="mi">16</span><span class="p">.</span><span class="n">dp</span><span class="p">))</span> <span class="p">{</span>
    <span class="nc">Text</span><span class="p">(</span>
      <span class="n">text</span> <span class="p">=</span> <span class="n">name</span><span class="p">,</span>
      <span class="n">style</span> <span class="p">=</span> <span class="nc">MaterialTheme</span><span class="p">.</span><span class="n">typography</span><span class="p">.</span><span class="n">h6</span>
    <span class="p">)</span>
    <span class="nf">textComposable</span><span class="p">(</span><span class="n">lastname</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Composable functions can also have the type <code class="language-plaintext highlighter-rouge">@Composable Scope.() -&gt; A</code>, frequently used for scoping information to a specific Composable only:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">inline</span> <span class="k">fun</span> <span class="nf">Box</span><span class="p">(</span>
  <span class="o">..</span><span class="p">.,</span>
  <span class="n">content</span><span class="p">:</span> <span class="nd">@Composable</span> <span class="nc">BoxScope</span><span class="p">.()</span> <span class="p">-&gt;</span> <span class="nc">Unit</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="nc">Layout</span><span class="p">(</span>
    <span class="n">content</span> <span class="p">=</span> <span class="p">{</span> <span class="nc">BoxScopeInstance</span><span class="p">.</span><span class="nf">content</span><span class="p">()</span> <span class="p">},</span>
    <span class="n">measurePolicy</span> <span class="p">=</span> <span class="n">measurePolicy</span><span class="p">,</span>
    <span class="n">modifier</span> <span class="p">=</span> <span class="n">modifier</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>From a language perspective, types exist to provide information to the compiler in order to perform quick static validation, sometimes generate some convenient code, and to delimit/refine how the data can be used at runtime. The <code class="language-plaintext highlighter-rouge">@Composable</code> annotation changes how a function is validated and used at runtime, and that is also why they are considered to have a different type than normal functions.</p>

<div class="roundedbutton"><a target="_blank" href="https://leanpub.com/composeinternals/">Buy Jetpack Compose internals üí∏</a></div>

<hr />

<p><a id="preview" name="sponsor"></a>
<!-- ### <span style="font-family: 'Quicksand', 'Noto Sans', sans-serif;">Companies supporting the book</span> --></p>

<!--<div align="left">
  <img width="400" style="margin-left:0px;margin-top:40px;margin-bottom:40px;" src="../assets/images/getstream2.png"/>
</div>-->

<!--Build **real-time chat in less time** with Stream‚Äôs API & SDK solutions. [Activate your free Stream Chat trial](https://getstream.io/chat/trial/?utm_source=JetpackComposeInternals&utm_medium=Webpage_Content_Ad&utm_content=Developer&utm_campaign=JetpackComposeInternals_June2022_ChatTrial) to start building today.-->

<!-- > Stream is our current silver ü•à sponsor. Thanks to their support the book price is ‚è¨  **cut by a 25%** ‚è¨ until the beginning of July. This effectively makes it more accessible to devs from around the world. Find them in [getstream.io](https://getstream.io/).-->

<div style="border:2px dashed #cbd5e1;padding:20px;border-radius:8px;background-color:#f8fafc">
  <div class="grid gap-4 grid-cols-1 md:grid-cols-1 lg:grid-cols-2 xl:grid-cols-2">
    <div>
      <h2>Take the online course and join the exclusive community</h2>
      <div class="w-1/2 xs:text-start sm:text-start md:text-start text-start">
        <div class="avatars">
          <span class="avatar">
              <img src="../assets/images/paulfrancoavatar.jpeg" />
          </span>
          <span class="avatar">
              <img src="../assets/images/bkinyaavatar.jpeg" />
          </span>
          <span class="avatar">
                <img src="../assets/images/franciscovelazquezavatar.jpeg" />
            </span>
          <span class="avatar">
                <img src="../assets/images/aurelioavatar.jpeg" />
            </span>
          <span class="avatar">
                <img src="../assets/images/tashaavatar.jpeg" />
            </span>
          <span class="avatar">
              <img src="../assets/images/annyceavatar.jpeg" />
            </span>
        </div>
      </div>
    
      <p>Master Jetpack Compose and learn how to work efficiently with it by taking this course. Enjoy the perfect mix of theory and exercises with the best trainer ‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è</p>
      <div class="flex">
        <img class="flex-initial w-24 h-24" style="margin-right:16px; margin-top:8px; width: auto;" src="../assets/images/gdeavatar.png" />
        <span class="flex-auto">
        Created and delivered by Jorge Castillo, Google Developer Expert for Android and Kotlin
        </span>
      </div>
    </div>
    <div>
      <img src="../assets/images/logos.png" class="logos course-content-image" />
    </div>
  </div>
  <div class="mt-6">
    <a class="float-left font-recoleta blackBtnLarge" target="_blank" href="https://composeinternals.com/">Tell me more üöÄ</a>
    <a class="float-left font-recoleta transparentBtnLarge" target="_blank" href="https://composeinternals.com/#testimonials">Opinions from previous attendees</a>
  </div>
</div>

<h2 id="sponsoring-jetpack-compose-internals"><span style="font-family: 'Quicksand', 'Noto Sans', sans-serif;">Sponsoring Jetpack Compose internals</span></h2>

<p>Any company can become a sponsor. There are different sponsorship levels, but all of them will make the company appear in the book attributions page and in any existing book sites like <a href="https://leanpub.com/composeinternals/">Leanpub</a> and this page you are reading now. <em>The company will provide a paragraph that will be advertised along with the company name and logo</em>.</p>

<p>Any sponsorships will have a frequent prominent position on any relevant updates about the book shared in social media.</p>

<h3 id="sponsorship-levels"><span style="font-family: 'Quicksand', 'Noto Sans', sans-serif;">Sponsorship levels</span></h3>

<div align="left" style="margin-top:40px;">
  <div style="flex-grow:1">
    <p><b>Diamond</b> üíé</p>
    <p>A Diamond sponsor makes the book <b>completely free</b> for a month, so it becomes effectively accessible to every developer in the world. A Diamond sponsor has total exclusivity, if there is a diamond sponsor, no more sponsors will be accepted.</p>
    <p><b>Platinum</b> ‚ú®</p>
    <p>Platinum sponsors reduce the book price a 75% during a month. If there is more than one platinum sponsor, the book becomes completely free.</p>
    <p><b>Gold</b> ü•á</p>
    <p>Gold sponsors reduce the book price a 50% during a month. If there are three or more gold sponsors, the book becomes completely free.</p>
    <p><b>Silver</b> ü•à</p>
    <p>Silver sponsors reduce the book price a 25% during a month. If there are 4 silver sponsors or more, the book becomes completely free.</p>
    <p><b>Copper</b> ü•â</p>
    <p>Copper sponsors reduce the book price a 10% during a month.</p>
  </div>
</div>

<h3 id="previous-sponsors"><span style="font-family: 'Quicksand', 'Noto Sans', sans-serif;">Previous sponsors</span></h3>

<div align="left">
  <img style="margin-left:0px;margin-top:40px;margin-bottom:40px;" src="../assets/images/snapplogos.png" />
  <img width="200" style="margin-left:0px;margin-top:40px;margin-bottom:40px;" src="../assets/images/getstream2.png" />
</div>

<div style="height: 40px;"></div>
<h2 id="the-book-content"><span style="font-family: 'Quicksand', 'Noto Sans', sans-serif;">The book content</span></h2>

<blockquote>
  <p>The book covers following topics among many others.</p>
</blockquote>

<div class="flex-container">
  <div>
    <b>1. Composable functions</b>
    <p style="font-size:0.8em;margin-top:20px;">
    1. The nature of Composable functions<br />
    2. Composable function properties<br />
    3. Calling context<br />
    4. Idempotent<br />
    5. Free of side effects<br />
    6. Restartable<br />
    7. Fast execution<br />
    8. Positional memoization<br />
    9. Similarities with suspend functions<br />
    10. Composable functions are colored<br />
    11. Composable function types<br />
    </p>
  </div>
  <div>
    <b>2. The Compose Compiler</b>
    <p style="font-size:0.8em;margin-top:20px;">
    1. A Kotlin compiler plugin<br />
    2. Compose annotations<br />
    3. Registering compiler extensions<br />
    4. Static analysis and static checkers<br />
    5. Call, type, and declaration checks<br />
    6. Diagnostic suppression<br />
    7. Kotlin and runtime version checks<br />
    8. Code generation (IR) and lowering<br />
    9. Inferring class stability<br />
    10. Enabling live literals<br />
    11. Compose lambda memoization<br />
    12. Injecting the Composer<br />
    13. Comparison propagation<br />
    14. Default parameters<br />
    15. Control flow group generation<br />
    16. Klib and decoy generation<br />
    </p>
  </div>
  <div>
    <b>3. The Compose Runtime</b>
    <p style="font-size:0.8em;margin-top:20px;">
    1. The Slot table and the list of changes<br />
    2. Modeling the changes<br />
    3. The Composer and how it is fed<br />
    4. Writing and reading groups<br />
    5. Remembering values<br />
    6. Recompose scopes for recomposition<br />
    7. Side effects in the Composer<br />
    8. Storing CompositionLocals &amp; source info<br />
    9. Linking Compositions as a tree<br />
    10. The current State snapshot<br />
    11. Navigating the tree nodes<br />
    12. Performance when building the tree<br />
    13. Applying the changes<br />
    14. Attaching and drawing the nodes<br />
    15. Composition<br />
    16. Creating a Composition<br />
    17. The initial Composition process<br />
    18. Applying changes after Composition<br />
    19. The Recomposer<br />
    20. Recomposition process<br />
    21. Concurrent Recomposition<br />
    </p>
  </div>  
  <div>
    <b>4. Compose UI</b>
    <p style="font-size:0.8em;margin-top:20px;">
    1. Integrating UI with the Compose runtime<br />
    2. Mapping scheduled changes to actual changes to the tree<br />
    3. Composition from the point of view of Compose UI<br />
    4. Subcomposition from the point of view of Compose UI<br />
    5. Reflecting changes in the UI<br />
    6. Different types of Appliers<br />
    7. Materializing a new LayoutNode<br />
    8. Materializing a change to remove nodes<br />
    9. Materializing a change to move nodes<br />
    10. Materializing a change to clear all the nodes<br />
    11. setContent as the integration point to close the circle<br />
    12. Measuring in Compose UI<br />
    13. Measuring policies<br />
    14. Intrinsic measurements<br />
    15. Layout Constraints<br />
    16. Modeling modifier chains<br />
    17. Setting modifiers to the LayoutNode<br />
    18. How LayoutNode ingests new modifiers<br />
    19. Drawing the node tree<br />
    20. Semantics in Jetpack Compose<br />
    21. Notifying about semantic changes<br />
    22. Merged and unmerged semantic trees<br />
    </p>
  </div>
  <div>
    <b>5. The State snapshot system</b>
    <p style="font-size:0.8em;margin-top:20px;">
    1. What snapshost state is<br />
    2. Concurrency control systems<br />
    3. Multiversion concurrency control (MVCC)<br />
    4. The Snapshot<br />
    5. The snapshot tree<br />
    6. Snapshots and threading<br />
    7. Observing reads and writes<br />
    8. MutableSnapshots<br />
    9. GlobalSnapshot and nested snapshots<br />
    10. StateObjects and StateRecords<br />
    11. Reading and writing state<br />
    12. Removing or reusing obsolete records<br />
    13. Change propagation<br />
    14. Merging write conflicts<br />
    </p>
  </div>
  <div>
    <b>6. Smart recomposition</b>
    <p style="font-size:0.8em;margin-top:20px;color:gray;">
    1. To be written<br />
    2. To be written<br />
    3. To be written<br />
    4. To be written<br />
    5. To be written<br />
    6. To be written<br />
    7. To be written<br />
    8. To be written<br />
    9. To be written<br />
    10. To be written<br />
    11. To be written<br />
    12. To be written<br />
    13. To be written<br />
    14. To be written<br />
    </p>
  </div>  
  <div>
    <b>7. Effects and effect handlers</b>
    <p style="font-size:0.8em;margin-top:20px;">
    1. Introducing side effects<br />
    2. Side effects in Compose<br />
    3. What we need<br />
    4. Effect handlers<br />
    5. Non suspended effects<br />
    6. Suspended effects<br />
    7. Third party library adapters<br />
    </p>
  </div>
  <div>
    <b>8. The Composable lifecycle</b>
    <p style="font-size:0.8em;margin-top:20px;color:gray;">
    1. To be written<br />
    2. To be written<br />
    3. To be written<br />
    4. To be written<br />
    5. To be written<br />
    6. To be written<br />
    7. To be written<br />
    </p>
  </div>
  <div>
    <b>9. Advanced Compose use cases</b>
    <p style="font-size:0.8em;margin-top:20px;">
    1. Compose runtime vs Compose UI<br />
    2. Composition of vector graphics<br />
    3. Building vector image tree<br />
    4. Integrating vector composition into Compose UI<br />
    5. Managing DOM with Compose<br />
    6. Standalone composition in the browser<br />
    7. Conclusion<br />
    </p>
  </div>
</div>

<div style="border:2px dashed #cbd5e1;padding:20px;border-radius:8px;background-color:#f8fafc">
  <div class="grid gap-4 grid-cols-1 md:grid-cols-1 lg:grid-cols-2 xl:grid-cols-2">
    <div>
      <h2>Take the online course and join the exclusive community</h2>
      <div class="w-1/2 xs:text-start sm:text-start md:text-start text-start">
        <div class="avatars">
          <span class="avatar">
              <img src="../assets/images/paulfrancoavatar.jpeg" />
          </span>
          <span class="avatar">
              <img src="../assets/images/bkinyaavatar.jpeg" />
          </span>
          <span class="avatar">
                <img src="../assets/images/franciscovelazquezavatar.jpeg" />
            </span>
          <span class="avatar">
                <img src="../assets/images/aurelioavatar.jpeg" />
            </span>
          <span class="avatar">
                <img src="../assets/images/tashaavatar.jpeg" />
            </span>
          <span class="avatar">
              <img src="../assets/images/annyceavatar.jpeg" />
            </span>
        </div>
      </div>
    
      <p>Master Jetpack Compose and learn how to work efficiently with it by taking this course. Enjoy the perfect mix of theory and exercises with the best trainer ‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è</p>
      <div class="flex">
        <img class="flex-initial w-24 h-24" style="margin-right:16px; margin-top:8px; width: auto;" src="../assets/images/gdeavatar.png" />
        <span class="flex-auto">
        Created and delivered by Jorge Castillo, Google Developer Expert for Android and Kotlin
        </span>
      </div>
    </div>
    <div>
      <img src="../assets/images/logos.png" class="logos course-content-image" />
    </div>
  </div>
  <div class="mt-6">
    <a class="float-left font-recoleta blackBtnLarge" target="_blank" href="https://composeinternals.com/">Tell me more üöÄ</a>
    <a class="float-left font-recoleta transparentBtnLarge" target="_blank" href="https://composeinternals.com/#testimonials">Opinions from previous attendees</a>
  </div>
</div>

<h3 id="the-authors-and-the-project"><span style="font-family: 'Quicksand', 'Noto Sans', sans-serif;">The authors and the project</span></h3>

<p>This book is being written by me (<a href="https://www.twitter.com/JorgeCastilloPR">Jorge Castillo</a>) and <a href="https://twitter.com/shikasd_">Andrei Shikov</a>.</p>

<p>I started writing this book around a year ago, and it helped me to escape a bit from the events happening around and focus on something interesting. It started as a series of posts and suddenly became a book. It is a chance to challenge myself and learn more about a new technology. A great consequence is to be able to share all the gathered knowledge with others ü•≥</p>

<p>To write this book we explored the Jetpack Compose sources via <a href="https://cs.android.com">cs.android.com</a> and sources included in Android Studio. We also had to built our own side projects.</p>

<p>This book aims to gather all the relevant knowledge about Jetpack Compose internals so it works as a reference for the years to come. Jetpack Compose is the future of Android UI, but it will also gain relevance in other platforms given its multiplatform nature.</p>

<div style="height:20px;"></div>

<h3 id="support-me-by-buying-the-book"><span style="font-family: 'Quicksand', 'Noto Sans', sans-serif;">Support me by buying the book</span></h3>

<p>By buying the book you are not only rewarding the countless hours of effort invested, but also boosting my motivation to keep working on it üôè</p>

<div class="roundedbutton"><a target="_blank" href="https://leanpub.com/composeinternals/">Get the book</a></div>
<div class="roundedbuttonYellow"><a target="_blank" href="https://twitter.com/composeinternal/">Follow on Twitter</a></div>

<hr />

<p><img src="../assets/images/manuelvivo.png" alt="My portrait pic" style="width:128px;height:128px" /></p>
<div align="center" style="margin-bottom:20px"><b>Manuel Vivo</b></div>

<blockquote>
  <p>‚ÄúCertainly one of the best resources to learn about the internals of Jetpack Compose. The details in which everything is explained in the book are mind-blowing. 100% recommended for any developer interested in what Jetpack Compose does under the hood. Disclaimer: it does a lot!‚Äù</p>
</blockquote>

<p><img src="../assets/images/joeavatar.png" alt="My portrait pic" style="width:128px;height:128px" /></p>
<div align="center" style="margin-bottom:20px"><b>Joe Birch</b></div>

<blockquote>
  <p>‚ÄúBeing clearly explained and easily consumable, Jorge‚Äôs Jetpack Compose content has been a great learning resource. I‚Äôm really looking forward to picking up this book and soaking up all of the knowledge around these Compose topics!‚Äù</p>
</blockquote>

<p><img src="../assets/images/antonioleiva.png" alt="My portrait pic" style="width:128px;height:128px" /></p>
<div align="center" style="margin-bottom:20px"><b>Antonio Leiva</b></div>

<blockquote>
  <p>‚ÄúJorge is able to explain hard concepts in the simplest possible way. This book is another proof of his teaching abilities.‚Äù</p>
</blockquote>

<p><img src="../assets/images/enrique.png" alt="My portrait pic" style="width:128px;height:128px" /></p>
<div align="center" style="margin-bottom:20px"><b>Enrique L√≥pez-Ma√±as</b></div>

<blockquote>
  <p>‚ÄúJorge has done an astonishing job at presenting Compose and its internal to the masses. I can absolutely endorse his book for any developer interested in the peculiarities of Compose and eager to learn more about it.‚Äù</p>
</blockquote>

<p><img src="../assets/images/andrei.png" alt="My portrait pic" style="width:128px;height:128px" /></p>
<div align="center" style="margin-bottom:20px"><b>Andrei Shikov</b></div>

<blockquote>
  <p>‚ÄúJorge did an amazing job explaining how Compose works in smallest detail, and there‚Äôs so much more to it than only displaying UI. I thoroughly enjoyed hacking different things based on it, and I hope you will too!‚Äù</p>
</blockquote>

<p><img src="../assets/images/portrait.png" alt="My portrait pic" style="width:128px;height:128px" /></p>
<div align="center" style="margin-bottom:20px"><b>Jorge Castillo</b></div>

<blockquote>
  <p>‚ÄúThis book is one of the hardest challenges I‚Äôve faced as a developer. I‚Äôve put all my love and effort on creating a consciously crafted piece of knowledge.‚Äù</p>
</blockquote>

<div style="height:20px;"></div>

<h3 id="support-me-by-buying-the-book-1"><span style="font-family: 'Quicksand', 'Noto Sans', sans-serif;">Support me by buying the book</span></h3>

<p>By buying the book you are not only rewarding the countless hours of effort invested, but also boosting my motivation to keep working on it üôè</p>

<div class="roundedbutton"><a target="_blank" href="https://leanpub.com/composeinternals/">Get the book</a></div>
<div class="roundedbuttonYellow"><a target="_blank" href="https://twitter.com/composeinternal/">Follow on Twitter</a></div>
<div class="freeLabelButton"><a href="#preview">Read chapter 1 for FREE üëÄüëÜ</a></div>
<div class="secondaryButton"><a href="#sponsor">Sponsor the book üëÜ</a></div>

            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://jorgecastilloprz.github.io/">üë®‚Äçüíª Jorge Castillo</a> &copy; 2025</section>
                <section class="poweredby">
                    <a rel="me" href="https://androiddev.social/@jorge">Mastodon</a>
                </section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    <a href="https://twitter.com/jorgecastillopr" target="_blank" rel="noopener">Twitter</a>
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-142413286-1', 'auto');
  ga('send', 'pageview');

 </script>

<!-- 100% privacy-first analytics -->
<script async src="https://scripts.simpleanalyticscdn.com/latest.js"></script>


    <script defer data-domain="jorgecastillo.dev" src="https://plausible.io/js/script.js"></script>

    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
